/*
 * This file was automatically generated by EvoSuite
 * Sun Feb 17 13:03:26 GMT 2019
 */

package org.sat4j.minisat.constraints.card;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.math.BigInteger;
import java.util.Comparator;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import org.sat4j.core.ReadOnlyVecInt;
import org.sat4j.core.VecInt;
import org.sat4j.minisat.constraints.CardinalityDataStructure;
import org.sat4j.minisat.constraints.MixedDataStructureDanielWL;
import org.sat4j.minisat.constraints.card.MaxWatchCard;
import org.sat4j.minisat.constraints.cnf.Lits;
import org.sat4j.minisat.core.ILits;
import org.sat4j.minisat.core.IPhaseSelectionStrategy;
import org.sat4j.minisat.core.SearchParams;
import org.sat4j.minisat.core.Solver;
import org.sat4j.minisat.core.WatcherBasedPrimeImplicantStrategy;
import org.sat4j.minisat.learning.ActiveLearning;
import org.sat4j.minisat.learning.ClauseOnlyLearning;
import org.sat4j.minisat.learning.FixedLengthLearning;
import org.sat4j.minisat.learning.MiniSATLearning;
import org.sat4j.minisat.learning.PercentLengthLearning;
import org.sat4j.minisat.orders.NaturalStaticOrder;
import org.sat4j.minisat.orders.PositiveLiteralSelectionStrategy;
import org.sat4j.minisat.orders.PureOrder;
import org.sat4j.minisat.orders.RandomWalkDecorator;
import org.sat4j.minisat.orders.SubsetVarOrder;
import org.sat4j.minisat.orders.TabuListDecorator;
import org.sat4j.minisat.orders.VarOrderHeap;
import org.sat4j.minisat.restarts.ArminRestarts;
import org.sat4j.minisat.restarts.Glucose21Restarts;
import org.sat4j.minisat.restarts.LubyRestarts;
import org.sat4j.minisat.restarts.MiniSATRestarts;
import org.sat4j.specs.Constr;
import org.sat4j.specs.ILogAble;
import org.sat4j.specs.IVecInt;
import org.sat4j.specs.UnitPropagationListener;
import org.sat4j.specs.VarMapper;
import org.sat4j.tools.DotSearchTracing;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class MaxWatchCard_ESTest extends MaxWatchCard_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      CardinalityDataStructure cardinalityDataStructure0 = new CardinalityDataStructure();
      assertNotNull(cardinalityDataStructure0);
      
      ILits iLits0 = cardinalityDataStructure0.getVocabulary();
      assertNotNull(iLits0);
      assertEquals(0, iLits0.realnVars());
      assertEquals(0, iLits0.nVars());
      
      int int0 = iLits0.getFromPool(37);
      assertEquals(37, iLits0.nVars());
      assertEquals(1, iLits0.realnVars());
      assertEquals(74, int0);
      
      VecInt vecInt0 = new VecInt(74, 74);
      assertNotNull(vecInt0);
      assertFalse(vecInt0.isEmpty());
      assertEquals(74, vecInt0.last());
      assertEquals(74, vecInt0.size());
      
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(iLits0, vecInt0, true, 74);
      assertNotNull(maxWatchCard0);
      assertEquals(37, iLits0.nVars());
      assertEquals(1, iLits0.realnVars());
      assertEquals(0, vecInt0.size());
      assertTrue(vecInt0.isEmpty());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertFalse(maxWatchCard0.learnt());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertFalse(maxWatchCard0.simplify());
      assertEquals(74, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertTrue(maxWatchCard0.locked());
      assertEquals(74, maxWatchCard0.size());
      
      VecInt vecInt1 = new VecInt(37, 37);
      assertFalse(vecInt1.equals((Object)vecInt0));
      assertNotNull(vecInt1);
      assertEquals(37, vecInt1.size());
      assertFalse(vecInt1.isEmpty());
      assertEquals(37, vecInt1.last());
      
      int int1 = maxWatchCard0.getAssertionLevel(vecInt1, 52);
      assertFalse(vecInt0.equals((Object)vecInt1));
      assertFalse(vecInt1.equals((Object)vecInt0));
      assertFalse(int1 == int0);
      assertEquals(37, iLits0.nVars());
      assertEquals(1, iLits0.realnVars());
      assertEquals(0, vecInt0.size());
      assertTrue(vecInt0.isEmpty());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertFalse(maxWatchCard0.learnt());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertFalse(maxWatchCard0.simplify());
      assertEquals(74, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertTrue(maxWatchCard0.locked());
      assertEquals(74, maxWatchCard0.size());
      assertEquals(37, vecInt1.size());
      assertFalse(vecInt1.isEmpty());
      assertEquals(37, vecInt1.last());
      assertNotSame(vecInt0, vecInt1);
      assertNotSame(vecInt1, vecInt0);
      assertEquals((-1), int1);
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      CardinalityDataStructure cardinalityDataStructure0 = new CardinalityDataStructure();
      assertNotNull(cardinalityDataStructure0);
      
      ILits iLits0 = cardinalityDataStructure0.getVocabulary();
      assertNotNull(iLits0);
      assertEquals(0, iLits0.realnVars());
      assertEquals(0, iLits0.nVars());
      
      VecInt vecInt0 = new VecInt();
      assertNotNull(vecInt0);
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(iLits0, vecInt0, false, 16384);
      assertNotNull(maxWatchCard0);
      assertEquals(0, iLits0.realnVars());
      assertEquals(0, iLits0.nVars());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      assertTrue(maxWatchCard0.locked());
      assertEquals((-16384), maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertFalse(maxWatchCard0.learnt());
      assertFalse(maxWatchCard0.simplify());
      assertEquals(0, maxWatchCard0.size());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      
      IVecInt iVecInt0 = vecInt0.pop();
      assertNotNull(iVecInt0);
      assertFalse(vecInt0.isEmpty());
      assertEquals((-1), vecInt0.size());
      assertFalse(iVecInt0.isEmpty());
      assertEquals((-1), iVecInt0.size());
      assertSame(vecInt0, iVecInt0);
      assertSame(iVecInt0, vecInt0);
      
      int int0 = maxWatchCard0.getAssertionLevel(vecInt0, 0);
      assertEquals(0, iLits0.realnVars());
      assertEquals(0, iLits0.nVars());
      assertFalse(vecInt0.isEmpty());
      assertEquals((-1), vecInt0.size());
      assertTrue(maxWatchCard0.locked());
      assertEquals((-16384), maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertFalse(maxWatchCard0.learnt());
      assertFalse(maxWatchCard0.simplify());
      assertEquals(0, maxWatchCard0.size());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertSame(vecInt0, iVecInt0);
      assertEquals((-1), int0);
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      CardinalityDataStructure cardinalityDataStructure0 = new CardinalityDataStructure();
      assertNotNull(cardinalityDataStructure0);
      
      ILits iLits0 = cardinalityDataStructure0.getVocabulary();
      assertNotNull(iLits0);
      assertEquals(0, iLits0.nVars());
      assertEquals(0, iLits0.realnVars());
      
      int int0 = iLits0.getFromPool(37);
      assertEquals(37, iLits0.nVars());
      assertEquals(1, iLits0.realnVars());
      assertEquals(74, int0);
      
      SearchParams searchParams0 = new SearchParams();
      assertNotNull(searchParams0);
      assertEquals(100, searchParams0.getInitConflictBound());
      assertEquals(0.95, searchParams0.getVarDecay(), 0.01);
      assertEquals(0.999, searchParams0.getClaDecay(), 0.01);
      assertEquals(1.5, searchParams0.getConflictBoundIncFactor(), 0.01);
      
      Glucose21Restarts glucose21Restarts0 = new Glucose21Restarts();
      assertNotNull(glucose21Restarts0);
      assertEquals(0L, glucose21Restarts0.nextRestartNumberOfConflict());
      assertEquals("Glucose 2.1 dynamic restart strategy", glucose21Restarts0.toString());
      
      VecInt vecInt0 = new VecInt(74, 74);
      assertNotNull(vecInt0);
      assertEquals(74, vecInt0.size());
      assertFalse(vecInt0.isEmpty());
      assertEquals(74, vecInt0.last());
      
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(iLits0, vecInt0, true, 74);
      assertNotNull(maxWatchCard0);
      assertEquals(37, iLits0.nVars());
      assertEquals(1, iLits0.realnVars());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertTrue(maxWatchCard0.locked());
      assertEquals(74, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertEquals(74, maxWatchCard0.size());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertFalse(maxWatchCard0.simplify());
      assertFalse(maxWatchCard0.learnt());
      
      PercentLengthLearning<MixedDataStructureDanielWL> percentLengthLearning0 = new PercentLengthLearning<MixedDataStructureDanielWL>();
      assertNotNull(percentLengthLearning0);
      assertEquals(10, percentLengthLearning0.getLimit());
      
      MixedDataStructureDanielWL mixedDataStructureDanielWL0 = new MixedDataStructureDanielWL();
      assertNotNull(mixedDataStructureDanielWL0);
      
      PositiveLiteralSelectionStrategy positiveLiteralSelectionStrategy0 = new PositiveLiteralSelectionStrategy();
      assertNotNull(positiveLiteralSelectionStrategy0);
      assertEquals("positive phase selection", positiveLiteralSelectionStrategy0.toString());
      
      VarOrderHeap varOrderHeap0 = new VarOrderHeap(positiveLiteralSelectionStrategy0);
      assertNotNull(varOrderHeap0);
      assertEquals("positive phase selection", positiveLiteralSelectionStrategy0.toString());
      assertEquals(0, varOrderHeap0.numberOfInterestingVariables());
      
      TabuListDecorator tabuListDecorator0 = new TabuListDecorator(varOrderHeap0);
      assertNotNull(tabuListDecorator0);
      assertEquals("positive phase selection", positiveLiteralSelectionStrategy0.toString());
      assertEquals(0, varOrderHeap0.numberOfInterestingVariables());
      
      Solver<MixedDataStructureDanielWL> solver0 = new Solver<MixedDataStructureDanielWL>(percentLengthLearning0, mixedDataStructureDanielWL0, searchParams0, tabuListDecorator0, glucose21Restarts0);
      assertNotNull(solver0);
      assertEquals(100, searchParams0.getInitConflictBound());
      assertEquals(0.95, searchParams0.getVarDecay(), 0.01);
      assertEquals(0.999, searchParams0.getClaDecay(), 0.01);
      assertEquals(1.5, searchParams0.getConflictBoundIncFactor(), 0.01);
      assertEquals(0L, glucose21Restarts0.nextRestartNumberOfConflict());
      assertEquals("Glucose 2.1 dynamic restart strategy", glucose21Restarts0.toString());
      assertEquals(10, percentLengthLearning0.getLimit());
      assertEquals("positive phase selection", positiveLiteralSelectionStrategy0.toString());
      assertEquals(0, varOrderHeap0.numberOfInterestingVariables());
      assertEquals(0, solver0.nVars());
      assertEquals("c ", solver0.getLogPrefix());
      assertEquals(0, solver0.currentDecisionLevel());
      assertEquals(0, solver0.getPropagationLevel());
      assertFalse(solver0.isDBSimplificationAllowed());
      assertFalse(solver0.isVerbose());
      assertEquals(0, solver0.decisionLevel());
      assertEquals(2147483, solver0.getTimeout());
      assertEquals(0, solver0.nConstraints());
      assertFalse(solver0.isSolverKeptHot());
      assertEquals(0, solver0.realNumberOfVariables());
      
      maxWatchCard0.assertConstraint(solver0);
      assertEquals(37, iLits0.nVars());
      assertEquals(1, iLits0.realnVars());
      assertEquals(100, searchParams0.getInitConflictBound());
      assertEquals(0.95, searchParams0.getVarDecay(), 0.01);
      assertEquals(0.999, searchParams0.getClaDecay(), 0.01);
      assertEquals(1.5, searchParams0.getConflictBoundIncFactor(), 0.01);
      assertEquals(0L, glucose21Restarts0.nextRestartNumberOfConflict());
      assertEquals("Glucose 2.1 dynamic restart strategy", glucose21Restarts0.toString());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertTrue(maxWatchCard0.locked());
      assertEquals(74, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertEquals(74, maxWatchCard0.size());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertFalse(maxWatchCard0.simplify());
      assertFalse(maxWatchCard0.learnt());
      assertEquals(10, percentLengthLearning0.getLimit());
      assertEquals("positive phase selection", positiveLiteralSelectionStrategy0.toString());
      assertEquals(0, varOrderHeap0.numberOfInterestingVariables());
      assertEquals(0, solver0.nVars());
      assertEquals("c ", solver0.getLogPrefix());
      assertEquals(0, solver0.currentDecisionLevel());
      assertEquals(1, solver0.getPropagationLevel());
      assertFalse(solver0.isDBSimplificationAllowed());
      assertFalse(solver0.isVerbose());
      assertEquals(0, solver0.decisionLevel());
      assertEquals(2147483, solver0.getTimeout());
      assertEquals(0, solver0.nConstraints());
      assertFalse(solver0.isSolverKeptHot());
      assertEquals(0, solver0.realNumberOfVariables());
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      Lits lits0 = new Lits();
      assertNotNull(lits0);
      assertEquals(0, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      
      int int0 = lits0.getFromPool(12);
      assertEquals(1, lits0.realnVars());
      assertEquals(12, lits0.nVars());
      assertEquals(24, int0);
      
      Glucose21Restarts glucose21Restarts0 = new Glucose21Restarts();
      assertNotNull(glucose21Restarts0);
      assertEquals(0L, glucose21Restarts0.nextRestartNumberOfConflict());
      assertEquals("Glucose 2.1 dynamic restart strategy", glucose21Restarts0.toString());
      
      VecInt vecInt0 = new VecInt(24, 24);
      assertNotNull(vecInt0);
      assertEquals(24, vecInt0.last());
      assertFalse(vecInt0.isEmpty());
      assertEquals(24, vecInt0.size());
      
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(lits0, vecInt0, false, 24);
      assertNotNull(maxWatchCard0);
      assertEquals(1, lits0.realnVars());
      assertEquals(12, lits0.nVars());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertFalse(maxWatchCard0.simplify());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertFalse(maxWatchCard0.learnt());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertEquals(0, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertEquals(24, maxWatchCard0.size());
      assertTrue(maxWatchCard0.locked());
      
      PercentLengthLearning<MixedDataStructureDanielWL> percentLengthLearning0 = new PercentLengthLearning<MixedDataStructureDanielWL>();
      assertNotNull(percentLengthLearning0);
      assertEquals(10, percentLengthLearning0.getLimit());
      
      MixedDataStructureDanielWL mixedDataStructureDanielWL0 = new MixedDataStructureDanielWL();
      assertNotNull(mixedDataStructureDanielWL0);
      
      PureOrder pureOrder0 = new PureOrder(2824);
      assertNotNull(pureOrder0);
      assertEquals(2824, pureOrder0.getPeriod());
      assertEquals(0, pureOrder0.numberOfInterestingVariables());
      assertEquals("tries to first branch on a single phase watched unassigned variable (pure literal if using a CB data structure) else VSIDS from MiniSAT", pureOrder0.toString());
      
      TabuListDecorator tabuListDecorator0 = new TabuListDecorator(pureOrder0, 24);
      assertNotNull(tabuListDecorator0);
      assertEquals(2824, pureOrder0.getPeriod());
      assertEquals(0, pureOrder0.numberOfInterestingVariables());
      assertEquals("tries to first branch on a single phase watched unassigned variable (pure literal if using a CB data structure) else VSIDS from MiniSAT", pureOrder0.toString());
      
      Solver<MixedDataStructureDanielWL> solver0 = new Solver<MixedDataStructureDanielWL>(percentLengthLearning0, mixedDataStructureDanielWL0, tabuListDecorator0, glucose21Restarts0);
      assertNotNull(solver0);
      assertEquals(0L, glucose21Restarts0.nextRestartNumberOfConflict());
      assertEquals("Glucose 2.1 dynamic restart strategy", glucose21Restarts0.toString());
      assertEquals(10, percentLengthLearning0.getLimit());
      assertEquals(2824, pureOrder0.getPeriod());
      assertEquals(0, pureOrder0.numberOfInterestingVariables());
      assertEquals("tries to first branch on a single phase watched unassigned variable (pure literal if using a CB data structure) else VSIDS from MiniSAT", pureOrder0.toString());
      assertEquals(0, solver0.nVars());
      assertEquals("c ", solver0.getLogPrefix());
      assertEquals(0, solver0.realNumberOfVariables());
      assertEquals(0, solver0.nConstraints());
      assertEquals(2147483, solver0.getTimeout());
      assertFalse(solver0.isSolverKeptHot());
      assertEquals(0, solver0.decisionLevel());
      assertEquals(0, solver0.getPropagationLevel());
      assertFalse(solver0.isDBSimplificationAllowed());
      assertFalse(solver0.isVerbose());
      assertEquals(0, solver0.currentDecisionLevel());
      
      maxWatchCard0.remove(solver0);
      assertEquals(1, lits0.realnVars());
      assertEquals(12, lits0.nVars());
      assertEquals(0L, glucose21Restarts0.nextRestartNumberOfConflict());
      assertEquals("Glucose 2.1 dynamic restart strategy", glucose21Restarts0.toString());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertFalse(maxWatchCard0.simplify());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertFalse(maxWatchCard0.learnt());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertEquals(0, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertEquals(24, maxWatchCard0.size());
      assertTrue(maxWatchCard0.locked());
      assertEquals(10, percentLengthLearning0.getLimit());
      assertEquals(2824, pureOrder0.getPeriod());
      assertEquals(0, pureOrder0.numberOfInterestingVariables());
      assertEquals("tries to first branch on a single phase watched unassigned variable (pure literal if using a CB data structure) else VSIDS from MiniSAT", pureOrder0.toString());
      assertEquals(0, solver0.nVars());
      assertEquals("c ", solver0.getLogPrefix());
      assertEquals(0, solver0.realNumberOfVariables());
      assertEquals(0, solver0.nConstraints());
      assertEquals(2147483, solver0.getTimeout());
      assertFalse(solver0.isSolverKeptHot());
      assertEquals(0, solver0.decisionLevel());
      assertEquals(0, solver0.getPropagationLevel());
      assertFalse(solver0.isDBSimplificationAllowed());
      assertFalse(solver0.isVerbose());
      assertEquals(0, solver0.currentDecisionLevel());
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      CardinalityDataStructure cardinalityDataStructure0 = new CardinalityDataStructure();
      assertNotNull(cardinalityDataStructure0);
      
      ILits iLits0 = cardinalityDataStructure0.getVocabulary();
      assertNotNull(iLits0);
      assertEquals(0, iLits0.realnVars());
      assertEquals(0, iLits0.nVars());
      
      PureOrder pureOrder0 = new PureOrder(16384);
      assertNotNull(pureOrder0);
      assertEquals("tries to first branch on a single phase watched unassigned variable (pure literal if using a CB data structure) else VSIDS from MiniSAT", pureOrder0.toString());
      assertEquals(16384, pureOrder0.getPeriod());
      assertEquals(0, pureOrder0.numberOfInterestingVariables());
      
      MixedDataStructureDanielWL mixedDataStructureDanielWL0 = new MixedDataStructureDanielWL();
      assertNotNull(mixedDataStructureDanielWL0);
      
      int int0 = iLits0.getFromPool(0);
      assertEquals(1, iLits0.realnVars());
      assertEquals(0, iLits0.nVars());
      assertEquals(0, int0);
      
      MiniSATRestarts miniSATRestarts0 = new MiniSATRestarts();
      assertNotNull(miniSATRestarts0);
      assertTrue(miniSATRestarts0.shouldRestart());
      assertEquals(0L, miniSATRestarts0.nextRestartNumberOfConflict());
      assertEquals("MiniSAT restarts strategy", miniSATRestarts0.toString());
      
      VecInt vecInt0 = new VecInt();
      assertNotNull(vecInt0);
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(iLits0, vecInt0, false, 16384);
      assertNotNull(maxWatchCard0);
      assertEquals(1, iLits0.realnVars());
      assertEquals(0, iLits0.nVars());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      assertEquals(0, maxWatchCard0.size());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertFalse(maxWatchCard0.learnt());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertEquals((-16384), maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertTrue(maxWatchCard0.locked());
      assertFalse(maxWatchCard0.simplify());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      
      FixedLengthLearning<MixedDataStructureDanielWL> fixedLengthLearning0 = new FixedLengthLearning<MixedDataStructureDanielWL>();
      assertNotNull(fixedLengthLearning0);
      assertEquals(3, fixedLengthLearning0.getMaxLength());
      
      Solver<MixedDataStructureDanielWL> solver0 = new Solver<MixedDataStructureDanielWL>(fixedLengthLearning0, mixedDataStructureDanielWL0, pureOrder0, miniSATRestarts0);
      assertNotNull(solver0);
      assertEquals("tries to first branch on a single phase watched unassigned variable (pure literal if using a CB data structure) else VSIDS from MiniSAT", pureOrder0.toString());
      assertEquals(16384, pureOrder0.getPeriod());
      assertEquals(0, pureOrder0.numberOfInterestingVariables());
      assertTrue(miniSATRestarts0.shouldRestart());
      assertEquals(0L, miniSATRestarts0.nextRestartNumberOfConflict());
      assertEquals("MiniSAT restarts strategy", miniSATRestarts0.toString());
      assertEquals(3, fixedLengthLearning0.getMaxLength());
      assertEquals(0, solver0.decisionLevel());
      assertEquals(2147483, solver0.getTimeout());
      assertEquals(0, solver0.currentDecisionLevel());
      assertEquals(0, solver0.getPropagationLevel());
      assertFalse(solver0.isVerbose());
      assertFalse(solver0.isDBSimplificationAllowed());
      assertEquals("c ", solver0.getLogPrefix());
      assertEquals(0, solver0.nVars());
      assertFalse(solver0.isSolverKeptHot());
      assertEquals(0, solver0.realNumberOfVariables());
      assertEquals(0, solver0.nConstraints());
      
      boolean boolean0 = maxWatchCard0.propagate(solver0, 0);
      assertEquals(1, iLits0.realnVars());
      assertEquals(0, iLits0.nVars());
      assertEquals("tries to first branch on a single phase watched unassigned variable (pure literal if using a CB data structure) else VSIDS from MiniSAT", pureOrder0.toString());
      assertEquals(16384, pureOrder0.getPeriod());
      assertEquals(0, pureOrder0.numberOfInterestingVariables());
      assertTrue(miniSATRestarts0.shouldRestart());
      assertEquals(0L, miniSATRestarts0.nextRestartNumberOfConflict());
      assertEquals("MiniSAT restarts strategy", miniSATRestarts0.toString());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      assertEquals(0, maxWatchCard0.size());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertFalse(maxWatchCard0.learnt());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertEquals((-16384), maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertTrue(maxWatchCard0.locked());
      assertFalse(maxWatchCard0.simplify());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertEquals(3, fixedLengthLearning0.getMaxLength());
      assertEquals(0, solver0.decisionLevel());
      assertEquals(2147483, solver0.getTimeout());
      assertEquals(0, solver0.currentDecisionLevel());
      assertEquals(0, solver0.getPropagationLevel());
      assertFalse(solver0.isVerbose());
      assertFalse(solver0.isDBSimplificationAllowed());
      assertEquals("c ", solver0.getLogPrefix());
      assertEquals(0, solver0.nVars());
      assertFalse(solver0.isSolverKeptHot());
      assertEquals(0, solver0.realNumberOfVariables());
      assertEquals(0, solver0.nConstraints());
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      CardinalityDataStructure cardinalityDataStructure0 = new CardinalityDataStructure();
      assertNotNull(cardinalityDataStructure0);
      
      ILits iLits0 = cardinalityDataStructure0.getVocabulary();
      assertNotNull(iLits0);
      assertEquals(0, iLits0.realnVars());
      assertEquals(0, iLits0.nVars());
      
      VecInt vecInt0 = new VecInt(1);
      assertNotNull(vecInt0);
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      
      IVecInt iVecInt0 = vecInt0.push(1);
      assertNotNull(iVecInt0);
      assertFalse(vecInt0.isEmpty());
      assertEquals(1, vecInt0.size());
      assertEquals(1, vecInt0.last());
      assertFalse(iVecInt0.isEmpty());
      assertEquals(1, iVecInt0.size());
      assertEquals(1, iVecInt0.last());
      assertSame(vecInt0, iVecInt0);
      assertSame(iVecInt0, vecInt0);
      
      MaxWatchCard maxWatchCard0 = null;
      try {
        maxWatchCard0 = new MaxWatchCard(iLits0, iVecInt0, false, 1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      Lits lits0 = new Lits();
      assertNotNull(lits0);
      assertEquals(0, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      
      VecInt vecInt0 = new VecInt(2120, 0);
      assertNotNull(vecInt0);
      assertFalse(vecInt0.isEmpty());
      assertEquals(2120, vecInt0.size());
      assertEquals(0, vecInt0.last());
      
      int int0 = lits0.getFromPool(0);
      assertEquals(1, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      assertEquals(0, int0);
      
      SearchParams searchParams0 = new SearchParams(2120);
      assertNotNull(searchParams0);
      assertEquals(0.95, searchParams0.getVarDecay(), 0.01);
      assertEquals(1.5, searchParams0.getConflictBoundIncFactor(), 0.01);
      assertEquals(2120, searchParams0.getInitConflictBound());
      assertEquals(0.999, searchParams0.getClaDecay(), 0.01);
      
      PureOrder pureOrder0 = new PureOrder();
      assertNotNull(pureOrder0);
      assertEquals(0, pureOrder0.numberOfInterestingVariables());
      assertEquals("tries to first branch on a single phase watched unassigned variable (pure literal if using a CB data structure) else VSIDS from MiniSAT", pureOrder0.toString());
      assertEquals(20, pureOrder0.getPeriod());
      
      Glucose21Restarts glucose21Restarts0 = new Glucose21Restarts();
      assertNotNull(glucose21Restarts0);
      assertEquals(0L, glucose21Restarts0.nextRestartNumberOfConflict());
      assertEquals("Glucose 2.1 dynamic restart strategy", glucose21Restarts0.toString());
      
      ILogAble iLogAble0 = ILogAble.CONSOLE;
      assertNotNull(iLogAble0);
      
      ClauseOnlyLearning<MixedDataStructureDanielWL> clauseOnlyLearning0 = new ClauseOnlyLearning<MixedDataStructureDanielWL>();
      assertNotNull(clauseOnlyLearning0);
      assertEquals("Limit learning to clauses using watched literals only", clauseOnlyLearning0.toString());
      
      MixedDataStructureDanielWL mixedDataStructureDanielWL0 = new MixedDataStructureDanielWL();
      assertNotNull(mixedDataStructureDanielWL0);
      
      Solver<MixedDataStructureDanielWL> solver0 = new Solver<MixedDataStructureDanielWL>(clauseOnlyLearning0, mixedDataStructureDanielWL0, searchParams0, pureOrder0, glucose21Restarts0, iLogAble0);
      assertNotNull(solver0);
      assertEquals(0.95, searchParams0.getVarDecay(), 0.01);
      assertEquals(1.5, searchParams0.getConflictBoundIncFactor(), 0.01);
      assertEquals(2120, searchParams0.getInitConflictBound());
      assertEquals(0.999, searchParams0.getClaDecay(), 0.01);
      assertEquals(0, pureOrder0.numberOfInterestingVariables());
      assertEquals("tries to first branch on a single phase watched unassigned variable (pure literal if using a CB data structure) else VSIDS from MiniSAT", pureOrder0.toString());
      assertEquals(20, pureOrder0.getPeriod());
      assertEquals(0L, glucose21Restarts0.nextRestartNumberOfConflict());
      assertEquals("Glucose 2.1 dynamic restart strategy", glucose21Restarts0.toString());
      assertEquals("Limit learning to clauses using watched literals only", clauseOnlyLearning0.toString());
      assertEquals(2147483, solver0.getTimeout());
      assertFalse(solver0.isDBSimplificationAllowed());
      assertEquals(0, solver0.getPropagationLevel());
      assertFalse(solver0.isVerbose());
      assertEquals(0, solver0.currentDecisionLevel());
      assertEquals(0, solver0.nVars());
      assertEquals(0, solver0.decisionLevel());
      assertEquals("c ", solver0.getLogPrefix());
      assertEquals(0, solver0.nConstraints());
      assertFalse(solver0.isSolverKeptHot());
      assertEquals(0, solver0.realNumberOfVariables());
      
      Constr constr0 = MaxWatchCard.maxWatchCardNew(solver0, lits0, vecInt0, true, 0);
      assertNull(constr0);
      assertEquals(1, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      assertEquals(0.95, searchParams0.getVarDecay(), 0.01);
      assertEquals(1.5, searchParams0.getConflictBoundIncFactor(), 0.01);
      assertEquals(2120, searchParams0.getInitConflictBound());
      assertEquals(0.999, searchParams0.getClaDecay(), 0.01);
      assertEquals(0, pureOrder0.numberOfInterestingVariables());
      assertEquals("tries to first branch on a single phase watched unassigned variable (pure literal if using a CB data structure) else VSIDS from MiniSAT", pureOrder0.toString());
      assertEquals(20, pureOrder0.getPeriod());
      assertEquals(0L, glucose21Restarts0.nextRestartNumberOfConflict());
      assertEquals("Glucose 2.1 dynamic restart strategy", glucose21Restarts0.toString());
      assertEquals("Limit learning to clauses using watched literals only", clauseOnlyLearning0.toString());
      assertEquals(2147483, solver0.getTimeout());
      assertFalse(solver0.isDBSimplificationAllowed());
      assertEquals(0, solver0.getPropagationLevel());
      assertFalse(solver0.isVerbose());
      assertEquals(0, solver0.currentDecisionLevel());
      assertEquals(0, solver0.nVars());
      assertEquals(0, solver0.decisionLevel());
      assertEquals("c ", solver0.getLogPrefix());
      assertEquals(0, solver0.nConstraints());
      assertFalse(solver0.isSolverKeptHot());
      assertEquals(0, solver0.realNumberOfVariables());
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      Lits lits0 = new Lits();
      assertNotNull(lits0);
      assertEquals(0, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      
      VecInt vecInt0 = new VecInt(2120, 0);
      assertNotNull(vecInt0);
      assertFalse(vecInt0.isEmpty());
      assertEquals(0, vecInt0.last());
      assertEquals(2120, vecInt0.size());
      
      int int0 = lits0.getFromPool(0);
      assertEquals(0, lits0.nVars());
      assertEquals(1, lits0.realnVars());
      assertEquals(0, int0);
      
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(lits0, vecInt0, false, 0);
      assertNotNull(maxWatchCard0);
      assertEquals(0, lits0.nVars());
      assertEquals(1, lits0.realnVars());
      assertEquals(0, vecInt0.size());
      assertTrue(vecInt0.isEmpty());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertFalse(maxWatchCard0.learnt());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertFalse(maxWatchCard0.simplify());
      assertEquals(2120, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertEquals(2120, maxWatchCard0.size());
      assertTrue(maxWatchCard0.locked());
      
      int int1 = maxWatchCard0.size();
      assertFalse(int1 == int0);
      assertEquals(0, lits0.nVars());
      assertEquals(1, lits0.realnVars());
      assertEquals(0, vecInt0.size());
      assertTrue(vecInt0.isEmpty());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertFalse(maxWatchCard0.learnt());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertFalse(maxWatchCard0.simplify());
      assertEquals(2120, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertEquals(2120, maxWatchCard0.size());
      assertTrue(maxWatchCard0.locked());
      assertEquals(2120, int1);
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      Lits lits0 = new Lits();
      assertNotNull(lits0);
      assertEquals(0, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      
      VecInt vecInt0 = new VecInt(0);
      assertNotNull(vecInt0);
      assertEquals(0, vecInt0.size());
      assertTrue(vecInt0.isEmpty());
      
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(lits0, vecInt0, true, 0);
      assertNotNull(maxWatchCard0);
      assertEquals(0, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      assertEquals(0, vecInt0.size());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertEquals(0, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertEquals(0, maxWatchCard0.size());
      assertFalse(maxWatchCard0.learnt());
      assertTrue(maxWatchCard0.locked());
      assertFalse(maxWatchCard0.simplify());
      
      int int0 = maxWatchCard0.requiredNumberOfSatisfiedLiterals();
      assertEquals(0, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      assertEquals(0, vecInt0.size());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertEquals(0, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertEquals(0, maxWatchCard0.size());
      assertFalse(maxWatchCard0.learnt());
      assertTrue(maxWatchCard0.locked());
      assertFalse(maxWatchCard0.simplify());
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      CardinalityDataStructure cardinalityDataStructure0 = new CardinalityDataStructure();
      assertNotNull(cardinalityDataStructure0);
      
      ILits iLits0 = cardinalityDataStructure0.getVocabulary();
      assertNotNull(iLits0);
      assertEquals(0, iLits0.realnVars());
      assertEquals(0, iLits0.nVars());
      
      VecInt vecInt0 = new VecInt(1);
      assertNotNull(vecInt0);
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(iLits0, vecInt0, false, 1);
      assertNotNull(maxWatchCard0);
      assertEquals(0, iLits0.realnVars());
      assertEquals(0, iLits0.nVars());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertEquals((-1), maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertTrue(maxWatchCard0.locked());
      assertFalse(maxWatchCard0.simplify());
      assertFalse(maxWatchCard0.learnt());
      assertEquals(0, maxWatchCard0.size());
      
      int int0 = maxWatchCard0.requiredNumberOfSatisfiedLiterals();
      assertEquals(0, iLits0.realnVars());
      assertEquals(0, iLits0.nVars());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertEquals((-1), maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertTrue(maxWatchCard0.locked());
      assertFalse(maxWatchCard0.simplify());
      assertFalse(maxWatchCard0.learnt());
      assertEquals(0, maxWatchCard0.size());
      assertEquals((-1), int0);
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      CardinalityDataStructure cardinalityDataStructure0 = new CardinalityDataStructure();
      assertNotNull(cardinalityDataStructure0);
      
      ILits iLits0 = cardinalityDataStructure0.getVocabulary();
      assertNotNull(iLits0);
      assertEquals(0, iLits0.realnVars());
      assertEquals(0, iLits0.nVars());
      
      int int0 = iLits0.getFromPool(2564);
      assertEquals(1, iLits0.realnVars());
      assertEquals(2564, iLits0.nVars());
      assertEquals(5128, int0);
      
      VecInt vecInt0 = new VecInt();
      assertNotNull(vecInt0);
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(iLits0, vecInt0, false, 5128);
      assertNotNull(maxWatchCard0);
      assertEquals(1, iLits0.realnVars());
      assertEquals(2564, iLits0.nVars());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      assertFalse(maxWatchCard0.learnt());
      assertEquals(0, maxWatchCard0.size());
      assertFalse(maxWatchCard0.simplify());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertEquals((-5128), maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertTrue(maxWatchCard0.locked());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      
      ILits iLits1 = maxWatchCard0.getVocabulary();
      assertNotNull(iLits1);
      assertEquals(1, iLits0.realnVars());
      assertEquals(2564, iLits0.nVars());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      assertFalse(maxWatchCard0.learnt());
      assertEquals(0, maxWatchCard0.size());
      assertFalse(maxWatchCard0.simplify());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertEquals((-5128), maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertTrue(maxWatchCard0.locked());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertEquals(2564, iLits1.nVars());
      assertEquals(1, iLits1.realnVars());
      assertSame(iLits0, iLits1);
      assertSame(iLits1, iLits0);
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      Lits lits0 = new Lits();
      assertNotNull(lits0);
      assertEquals(0, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      
      VecInt vecInt0 = new VecInt(0, 2120);
      assertNotNull(vecInt0);
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(lits0, vecInt0, false, 0);
      assertNotNull(maxWatchCard0);
      assertEquals(0, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertEquals(0, maxWatchCard0.size());
      assertFalse(maxWatchCard0.simplify());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertFalse(maxWatchCard0.learnt());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertEquals(0, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertTrue(maxWatchCard0.locked());
      
      BigInteger bigInteger0 = maxWatchCard0.getDegree();
      assertNotNull(bigInteger0);
      assertEquals(0, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertEquals(0, maxWatchCard0.size());
      assertFalse(maxWatchCard0.simplify());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertFalse(maxWatchCard0.learnt());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertEquals(0, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertTrue(maxWatchCard0.locked());
      assertEquals((byte)0, bigInteger0.byteValue());
      assertEquals((short)0, bigInteger0.shortValue());
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      Lits lits0 = new Lits();
      assertNotNull(lits0);
      assertEquals(0, lits0.nVars());
      assertEquals(0, lits0.realnVars());
      
      VecInt vecInt0 = new VecInt(0, 2120);
      assertNotNull(vecInt0);
      assertEquals(0, vecInt0.size());
      assertTrue(vecInt0.isEmpty());
      
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(lits0, vecInt0, true, 2120);
      assertNotNull(maxWatchCard0);
      assertEquals(0, lits0.nVars());
      assertEquals(0, lits0.realnVars());
      assertEquals(0, vecInt0.size());
      assertTrue(vecInt0.isEmpty());
      assertFalse(maxWatchCard0.simplify());
      assertEquals(2120, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertTrue(maxWatchCard0.locked());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertEquals(0, maxWatchCard0.size());
      assertFalse(maxWatchCard0.learnt());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      
      BigInteger bigInteger0 = maxWatchCard0.getDegree();
      assertNotNull(bigInteger0);
      assertEquals(0, lits0.nVars());
      assertEquals(0, lits0.realnVars());
      assertEquals(0, vecInt0.size());
      assertTrue(vecInt0.isEmpty());
      assertFalse(maxWatchCard0.simplify());
      assertEquals(2120, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertTrue(maxWatchCard0.locked());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertEquals(0, maxWatchCard0.size());
      assertFalse(maxWatchCard0.learnt());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertEquals((byte)72, bigInteger0.byteValue());
      assertEquals((short)2120, bigInteger0.shortValue());
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      Lits lits0 = new Lits();
      assertNotNull(lits0);
      assertEquals(0, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      
      VecInt vecInt0 = new VecInt(2120, 0);
      assertNotNull(vecInt0);
      assertFalse(vecInt0.isEmpty());
      assertEquals(0, vecInt0.last());
      assertEquals(2120, vecInt0.size());
      
      int int0 = lits0.getFromPool(0);
      assertEquals(1, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      assertEquals(0, int0);
      
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(lits0, vecInt0, true, 4943);
      assertNotNull(maxWatchCard0);
      assertEquals(1, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      assertEquals(0, vecInt0.size());
      assertTrue(vecInt0.isEmpty());
      assertFalse(maxWatchCard0.learnt());
      assertEquals(4943, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertTrue(maxWatchCard0.locked());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertFalse(maxWatchCard0.simplify());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertEquals(2120, maxWatchCard0.size());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      
      int int1 = maxWatchCard0.get(0);
      assertTrue(int1 == int0);
      assertEquals(1, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      assertEquals(0, vecInt0.size());
      assertTrue(vecInt0.isEmpty());
      assertFalse(maxWatchCard0.learnt());
      assertEquals(4943, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertTrue(maxWatchCard0.locked());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertFalse(maxWatchCard0.simplify());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertEquals(2120, maxWatchCard0.size());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertEquals(0, int1);
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      CardinalityDataStructure cardinalityDataStructure0 = new CardinalityDataStructure();
      assertNotNull(cardinalityDataStructure0);
      
      ILits iLits0 = cardinalityDataStructure0.getVocabulary();
      assertNotNull(iLits0);
      assertEquals(0, iLits0.nVars());
      assertEquals(0, iLits0.realnVars());
      
      int int0 = iLits0.getFromPool(2087);
      assertEquals(1, iLits0.realnVars());
      assertEquals(2087, iLits0.nVars());
      assertEquals(4174, int0);
      
      VecInt vecInt0 = new VecInt(48, 4174);
      assertNotNull(vecInt0);
      assertEquals(4174, vecInt0.last());
      assertFalse(vecInt0.isEmpty());
      assertEquals(48, vecInt0.size());
      
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(iLits0, vecInt0, true, (-4324));
      assertNotNull(maxWatchCard0);
      assertEquals(1, iLits0.realnVars());
      assertEquals(2087, iLits0.nVars());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      assertTrue(maxWatchCard0.locked());
      assertEquals((-4324), maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertFalse(maxWatchCard0.learnt());
      assertFalse(maxWatchCard0.simplify());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertEquals(48, maxWatchCard0.size());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      
      // Undeclared exception!
      try { 
        maxWatchCard0.toString((VarMapper) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.sat4j.minisat.constraints.card.MaxWatchCard", e);
      }
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      Lits lits0 = new Lits();
      assertNotNull(lits0);
      assertEquals(0, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      
      VecInt vecInt0 = new VecInt();
      assertNotNull(vecInt0);
      assertEquals(0, vecInt0.size());
      assertTrue(vecInt0.isEmpty());
      
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(lits0, vecInt0, false, 54);
      assertNotNull(maxWatchCard0);
      assertEquals(0, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      assertEquals(0, vecInt0.size());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, maxWatchCard0.size());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertFalse(maxWatchCard0.simplify());
      assertEquals((-54), maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertTrue(maxWatchCard0.locked());
      assertFalse(maxWatchCard0.learnt());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      
      // Undeclared exception!
      try { 
        maxWatchCard0.propagate((UnitPropagationListener) null, 54);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      Lits lits0 = new Lits();
      assertNotNull(lits0);
      assertEquals(0, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      
      VecInt vecInt0 = new VecInt(1309);
      assertNotNull(vecInt0);
      assertEquals(0, vecInt0.size());
      assertTrue(vecInt0.isEmpty());
      
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(lits0, vecInt0, false, 1309);
      assertNotNull(maxWatchCard0);
      assertEquals(0, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      assertEquals(0, vecInt0.size());
      assertTrue(vecInt0.isEmpty());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertFalse(maxWatchCard0.simplify());
      assertTrue(maxWatchCard0.locked());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertFalse(maxWatchCard0.learnt());
      assertEquals((-1309), maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertEquals(0, maxWatchCard0.size());
      
      // Undeclared exception!
      try { 
        maxWatchCard0.propagate((UnitPropagationListener) null, (-517));
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      CardinalityDataStructure cardinalityDataStructure0 = new CardinalityDataStructure();
      assertNotNull(cardinalityDataStructure0);
      
      ILits iLits0 = cardinalityDataStructure0.getVocabulary();
      assertNotNull(iLits0);
      assertEquals(0, iLits0.nVars());
      assertEquals(0, iLits0.realnVars());
      
      MixedDataStructureDanielWL mixedDataStructureDanielWL0 = new MixedDataStructureDanielWL();
      assertNotNull(mixedDataStructureDanielWL0);
      
      int int0 = iLits0.getFromPool(2564);
      assertEquals(2564, iLits0.nVars());
      assertEquals(1, iLits0.realnVars());
      assertEquals(5128, int0);
      
      SearchParams searchParams0 = new SearchParams();
      assertNotNull(searchParams0);
      assertEquals(0.95, searchParams0.getVarDecay(), 0.01);
      assertEquals(1.5, searchParams0.getConflictBoundIncFactor(), 0.01);
      assertEquals(0.999, searchParams0.getClaDecay(), 0.01);
      assertEquals(100, searchParams0.getInitConflictBound());
      
      MiniSATRestarts miniSATRestarts0 = new MiniSATRestarts();
      assertNotNull(miniSATRestarts0);
      assertEquals(0L, miniSATRestarts0.nextRestartNumberOfConflict());
      assertEquals("MiniSAT restarts strategy", miniSATRestarts0.toString());
      assertTrue(miniSATRestarts0.shouldRestart());
      
      ILogAble iLogAble0 = ILogAble.CONSOLE;
      assertNotNull(iLogAble0);
      
      VecInt vecInt0 = new VecInt();
      assertNotNull(vecInt0);
      assertEquals(0, vecInt0.size());
      assertTrue(vecInt0.isEmpty());
      
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(iLits0, vecInt0, false, 2564);
      assertNotNull(maxWatchCard0);
      assertEquals(2564, iLits0.nVars());
      assertEquals(1, iLits0.realnVars());
      assertEquals(0, vecInt0.size());
      assertTrue(vecInt0.isEmpty());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertEquals(0, maxWatchCard0.size());
      assertFalse(maxWatchCard0.learnt());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertFalse(maxWatchCard0.simplify());
      assertTrue(maxWatchCard0.locked());
      assertEquals((-2564), maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      
      FixedLengthLearning<MixedDataStructureDanielWL> fixedLengthLearning0 = new FixedLengthLearning<MixedDataStructureDanielWL>();
      assertNotNull(fixedLengthLearning0);
      assertEquals(3, fixedLengthLearning0.getMaxLength());
      
      PureOrder pureOrder0 = new PureOrder();
      assertNotNull(pureOrder0);
      assertEquals(20, pureOrder0.getPeriod());
      assertEquals("tries to first branch on a single phase watched unassigned variable (pure literal if using a CB data structure) else VSIDS from MiniSAT", pureOrder0.toString());
      assertEquals(0, pureOrder0.numberOfInterestingVariables());
      
      Solver<MixedDataStructureDanielWL> solver0 = new Solver<MixedDataStructureDanielWL>(fixedLengthLearning0, mixedDataStructureDanielWL0, searchParams0, pureOrder0, miniSATRestarts0, iLogAble0);
      assertNotNull(solver0);
      assertEquals(0.95, searchParams0.getVarDecay(), 0.01);
      assertEquals(1.5, searchParams0.getConflictBoundIncFactor(), 0.01);
      assertEquals(0.999, searchParams0.getClaDecay(), 0.01);
      assertEquals(100, searchParams0.getInitConflictBound());
      assertEquals(0L, miniSATRestarts0.nextRestartNumberOfConflict());
      assertEquals("MiniSAT restarts strategy", miniSATRestarts0.toString());
      assertTrue(miniSATRestarts0.shouldRestart());
      assertEquals(3, fixedLengthLearning0.getMaxLength());
      assertEquals(20, pureOrder0.getPeriod());
      assertEquals("tries to first branch on a single phase watched unassigned variable (pure literal if using a CB data structure) else VSIDS from MiniSAT", pureOrder0.toString());
      assertEquals(0, pureOrder0.numberOfInterestingVariables());
      assertEquals(0, solver0.getPropagationLevel());
      assertEquals(0, solver0.decisionLevel());
      assertEquals(0, solver0.nVars());
      assertEquals("c ", solver0.getLogPrefix());
      assertEquals(2147483, solver0.getTimeout());
      assertEquals(0, solver0.currentDecisionLevel());
      assertFalse(solver0.isDBSimplificationAllowed());
      assertFalse(solver0.isVerbose());
      assertEquals(0, solver0.nConstraints());
      assertFalse(solver0.isSolverKeptHot());
      assertEquals(0, solver0.realNumberOfVariables());
      
      // Undeclared exception!
      MaxWatchCard.maxWatchCardNew(solver0, iLits0, vecInt0, false, (-1881));
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      ClauseOnlyLearning<MixedDataStructureDanielWL> clauseOnlyLearning0 = new ClauseOnlyLearning<MixedDataStructureDanielWL>();
      assertNotNull(clauseOnlyLearning0);
      assertEquals("Limit learning to clauses using watched literals only", clauseOnlyLearning0.toString());
      
      MixedDataStructureDanielWL mixedDataStructureDanielWL0 = new MixedDataStructureDanielWL();
      assertNotNull(mixedDataStructureDanielWL0);
      
      SearchParams searchParams0 = new SearchParams(1680.565590123201, (-4465.662), 1.0, 0);
      assertNotNull(searchParams0);
      assertEquals(1.0, searchParams0.getConflictBoundIncFactor(), 0.01);
      assertEquals((-4465.662), searchParams0.getClaDecay(), 0.01);
      assertEquals(1680.565590123201, searchParams0.getVarDecay(), 0.01);
      assertEquals(0, searchParams0.getInitConflictBound());
      
      NaturalStaticOrder naturalStaticOrder0 = new NaturalStaticOrder();
      assertNotNull(naturalStaticOrder0);
      assertEquals("Natural static ordering", naturalStaticOrder0.toString());
      
      LubyRestarts lubyRestarts0 = new LubyRestarts();
      assertNotNull(lubyRestarts0);
      assertEquals(32, LubyRestarts.DEFAULT_LUBY_FACTOR);
      assertEquals(0L, lubyRestarts0.nextRestartNumberOfConflict());
      assertEquals(1, lubyRestarts0.luby());
      assertEquals(32, lubyRestarts0.getFactor());
      assertTrue(lubyRestarts0.shouldRestart());
      
      Solver<MixedDataStructureDanielWL> solver0 = new Solver<MixedDataStructureDanielWL>(clauseOnlyLearning0, mixedDataStructureDanielWL0, searchParams0, naturalStaticOrder0, lubyRestarts0);
      assertNotNull(solver0);
      assertEquals(32, LubyRestarts.DEFAULT_LUBY_FACTOR);
      assertEquals("Limit learning to clauses using watched literals only", clauseOnlyLearning0.toString());
      assertEquals(1.0, searchParams0.getConflictBoundIncFactor(), 0.01);
      assertEquals((-4465.662), searchParams0.getClaDecay(), 0.01);
      assertEquals(1680.565590123201, searchParams0.getVarDecay(), 0.01);
      assertEquals(0, searchParams0.getInitConflictBound());
      assertEquals("Natural static ordering", naturalStaticOrder0.toString());
      assertEquals(0L, lubyRestarts0.nextRestartNumberOfConflict());
      assertEquals(1, lubyRestarts0.luby());
      assertEquals(32, lubyRestarts0.getFactor());
      assertTrue(lubyRestarts0.shouldRestart());
      assertEquals("c ", solver0.getLogPrefix());
      assertFalse(solver0.isDBSimplificationAllowed());
      assertEquals(0, solver0.decisionLevel());
      assertEquals(0, solver0.nVars());
      assertEquals(0, solver0.realNumberOfVariables());
      assertFalse(solver0.isSolverKeptHot());
      assertEquals(0, solver0.nConstraints());
      assertEquals(2147483, solver0.getTimeout());
      assertEquals(0, solver0.getPropagationLevel());
      assertEquals(0, solver0.currentDecisionLevel());
      assertFalse(solver0.isVerbose());
      
      ILits iLits0 = solver0.getVocabulary();
      assertNotNull(iLits0);
      assertEquals(32, LubyRestarts.DEFAULT_LUBY_FACTOR);
      assertEquals("Limit learning to clauses using watched literals only", clauseOnlyLearning0.toString());
      assertEquals(1.0, searchParams0.getConflictBoundIncFactor(), 0.01);
      assertEquals((-4465.662), searchParams0.getClaDecay(), 0.01);
      assertEquals(1680.565590123201, searchParams0.getVarDecay(), 0.01);
      assertEquals(0, searchParams0.getInitConflictBound());
      assertEquals("Natural static ordering", naturalStaticOrder0.toString());
      assertEquals(0L, lubyRestarts0.nextRestartNumberOfConflict());
      assertEquals(1, lubyRestarts0.luby());
      assertEquals(32, lubyRestarts0.getFactor());
      assertTrue(lubyRestarts0.shouldRestart());
      assertEquals("c ", solver0.getLogPrefix());
      assertFalse(solver0.isDBSimplificationAllowed());
      assertEquals(0, solver0.decisionLevel());
      assertEquals(0, solver0.nVars());
      assertEquals(0, solver0.realNumberOfVariables());
      assertFalse(solver0.isSolverKeptHot());
      assertEquals(0, solver0.nConstraints());
      assertEquals(2147483, solver0.getTimeout());
      assertEquals(0, solver0.getPropagationLevel());
      assertEquals(0, solver0.currentDecisionLevel());
      assertFalse(solver0.isVerbose());
      assertEquals(0, iLits0.realnVars());
      assertEquals(0, iLits0.nVars());
      
      // Undeclared exception!
      try { 
        MaxWatchCard.maxWatchCardNew(solver0, iLits0, (IVecInt) null, true, 32);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.sat4j.minisat.constraints.card.MaxWatchCard", e);
      }
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      CardinalityDataStructure cardinalityDataStructure0 = new CardinalityDataStructure();
      assertNotNull(cardinalityDataStructure0);
      
      ILits iLits0 = cardinalityDataStructure0.getVocabulary();
      assertNotNull(iLits0);
      assertEquals(0, iLits0.realnVars());
      assertEquals(0, iLits0.nVars());
      
      PureOrder pureOrder0 = new PureOrder(16384);
      assertNotNull(pureOrder0);
      assertEquals("tries to first branch on a single phase watched unassigned variable (pure literal if using a CB data structure) else VSIDS from MiniSAT", pureOrder0.toString());
      assertEquals(16384, pureOrder0.getPeriod());
      assertEquals(0, pureOrder0.numberOfInterestingVariables());
      
      MixedDataStructureDanielWL mixedDataStructureDanielWL0 = new MixedDataStructureDanielWL();
      assertNotNull(mixedDataStructureDanielWL0);
      
      SearchParams searchParams0 = new SearchParams();
      assertNotNull(searchParams0);
      assertEquals(100, searchParams0.getInitConflictBound());
      assertEquals(0.999, searchParams0.getClaDecay(), 0.01);
      assertEquals(1.5, searchParams0.getConflictBoundIncFactor(), 0.01);
      assertEquals(0.95, searchParams0.getVarDecay(), 0.01);
      
      MiniSATRestarts miniSATRestarts0 = new MiniSATRestarts();
      assertNotNull(miniSATRestarts0);
      assertEquals(0L, miniSATRestarts0.nextRestartNumberOfConflict());
      assertTrue(miniSATRestarts0.shouldRestart());
      assertEquals("MiniSAT restarts strategy", miniSATRestarts0.toString());
      
      ILogAble iLogAble0 = ILogAble.CONSOLE;
      assertNotNull(iLogAble0);
      
      VecInt vecInt0 = new VecInt();
      assertNotNull(vecInt0);
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      
      IVecInt iVecInt0 = vecInt0.pop();
      assertNotNull(iVecInt0);
      assertFalse(vecInt0.isEmpty());
      assertEquals((-1), vecInt0.size());
      assertEquals((-1), iVecInt0.size());
      assertFalse(iVecInt0.isEmpty());
      assertSame(vecInt0, iVecInt0);
      assertSame(iVecInt0, vecInt0);
      
      FixedLengthLearning<MixedDataStructureDanielWL> fixedLengthLearning0 = new FixedLengthLearning<MixedDataStructureDanielWL>();
      assertNotNull(fixedLengthLearning0);
      assertEquals(3, fixedLengthLearning0.getMaxLength());
      
      Solver<MixedDataStructureDanielWL> solver0 = new Solver<MixedDataStructureDanielWL>(fixedLengthLearning0, mixedDataStructureDanielWL0, searchParams0, pureOrder0, miniSATRestarts0, iLogAble0);
      assertNotNull(solver0);
      assertEquals("tries to first branch on a single phase watched unassigned variable (pure literal if using a CB data structure) else VSIDS from MiniSAT", pureOrder0.toString());
      assertEquals(16384, pureOrder0.getPeriod());
      assertEquals(0, pureOrder0.numberOfInterestingVariables());
      assertEquals(100, searchParams0.getInitConflictBound());
      assertEquals(0.999, searchParams0.getClaDecay(), 0.01);
      assertEquals(1.5, searchParams0.getConflictBoundIncFactor(), 0.01);
      assertEquals(0.95, searchParams0.getVarDecay(), 0.01);
      assertEquals(0L, miniSATRestarts0.nextRestartNumberOfConflict());
      assertTrue(miniSATRestarts0.shouldRestart());
      assertEquals("MiniSAT restarts strategy", miniSATRestarts0.toString());
      assertEquals(3, fixedLengthLearning0.getMaxLength());
      assertEquals(0, solver0.getPropagationLevel());
      assertEquals(0, solver0.decisionLevel());
      assertEquals(0, solver0.nVars());
      assertEquals("c ", solver0.getLogPrefix());
      assertEquals(2147483, solver0.getTimeout());
      assertEquals(0, solver0.currentDecisionLevel());
      assertFalse(solver0.isDBSimplificationAllowed());
      assertFalse(solver0.isVerbose());
      assertEquals(0, solver0.nConstraints());
      assertFalse(solver0.isSolverKeptHot());
      assertEquals(0, solver0.realNumberOfVariables());
      
      // Undeclared exception!
      try { 
        MaxWatchCard.maxWatchCardNew(solver0, iLits0, vecInt0, false, (-1));
        fail("Expecting exception: NegativeArraySizeException");
      
      } catch(NegativeArraySizeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.sat4j.minisat.constraints.cnf.UnitClauses", e);
      }
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      Lits lits0 = new Lits();
      assertNotNull(lits0);
      assertEquals(0, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      
      VecInt vecInt0 = new VecInt(2120, 0);
      assertNotNull(vecInt0);
      assertFalse(vecInt0.isEmpty());
      assertEquals(2120, vecInt0.size());
      assertEquals(0, vecInt0.last());
      
      PureOrder pureOrder0 = new PureOrder();
      assertNotNull(pureOrder0);
      assertEquals(0, pureOrder0.numberOfInterestingVariables());
      assertEquals(20, pureOrder0.getPeriod());
      assertEquals("tries to first branch on a single phase watched unassigned variable (pure literal if using a CB data structure) else VSIDS from MiniSAT", pureOrder0.toString());
      
      Glucose21Restarts glucose21Restarts0 = new Glucose21Restarts();
      assertNotNull(glucose21Restarts0);
      assertEquals("Glucose 2.1 dynamic restart strategy", glucose21Restarts0.toString());
      assertEquals(0L, glucose21Restarts0.nextRestartNumberOfConflict());
      
      ClauseOnlyLearning<MixedDataStructureDanielWL> clauseOnlyLearning0 = new ClauseOnlyLearning<MixedDataStructureDanielWL>();
      assertNotNull(clauseOnlyLearning0);
      assertEquals("Limit learning to clauses using watched literals only", clauseOnlyLearning0.toString());
      
      MixedDataStructureDanielWL mixedDataStructureDanielWL0 = new MixedDataStructureDanielWL();
      assertNotNull(mixedDataStructureDanielWL0);
      
      Solver<MixedDataStructureDanielWL> solver0 = new Solver<MixedDataStructureDanielWL>(clauseOnlyLearning0, mixedDataStructureDanielWL0, pureOrder0, glucose21Restarts0);
      assertNotNull(solver0);
      assertEquals(0, pureOrder0.numberOfInterestingVariables());
      assertEquals(20, pureOrder0.getPeriod());
      assertEquals("tries to first branch on a single phase watched unassigned variable (pure literal if using a CB data structure) else VSIDS from MiniSAT", pureOrder0.toString());
      assertEquals("Glucose 2.1 dynamic restart strategy", glucose21Restarts0.toString());
      assertEquals(0L, glucose21Restarts0.nextRestartNumberOfConflict());
      assertEquals("Limit learning to clauses using watched literals only", clauseOnlyLearning0.toString());
      assertEquals(0, solver0.realNumberOfVariables());
      assertEquals(0, solver0.getPropagationLevel());
      assertFalse(solver0.isVerbose());
      assertEquals(0, solver0.decisionLevel());
      assertEquals(0, solver0.nVars());
      assertEquals(0, solver0.nConstraints());
      assertEquals(2147483, solver0.getTimeout());
      assertFalse(solver0.isSolverKeptHot());
      assertFalse(solver0.isDBSimplificationAllowed());
      assertEquals("c ", solver0.getLogPrefix());
      assertEquals(0, solver0.currentDecisionLevel());
      
      IVecInt iVecInt0 = vecInt0.push(2115);
      assertNotNull(iVecInt0);
      assertFalse(vecInt0.isEmpty());
      assertEquals(2115, vecInt0.last());
      assertEquals(2121, vecInt0.size());
      assertEquals(2115, iVecInt0.last());
      assertEquals(2121, iVecInt0.size());
      assertFalse(iVecInt0.isEmpty());
      assertSame(vecInt0, iVecInt0);
      assertSame(iVecInt0, vecInt0);
      
      // Undeclared exception!
      try { 
        MaxWatchCard.maxWatchCardNew(solver0, lits0, iVecInt0, true, 2120);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      Lits lits0 = new Lits();
      assertNotNull(lits0);
      assertEquals(0, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      
      VecInt vecInt0 = new VecInt(2120, 0);
      assertNotNull(vecInt0);
      assertFalse(vecInt0.isEmpty());
      assertEquals(2120, vecInt0.size());
      assertEquals(0, vecInt0.last());
      
      int int0 = lits0.getFromPool(0);
      assertEquals(1, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      assertEquals(0, int0);
      
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(lits0, vecInt0, true, 0);
      assertNotNull(maxWatchCard0);
      assertEquals(1, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      assertEquals(0, vecInt0.size());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertEquals(0, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertTrue(maxWatchCard0.locked());
      assertFalse(maxWatchCard0.learnt());
      assertEquals(2120, maxWatchCard0.size());
      assertFalse(maxWatchCard0.simplify());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      
      // Undeclared exception!
      try { 
        maxWatchCard0.getAssertionLevel((IVecInt) null, 1669);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.sat4j.minisat.constraints.card.MaxWatchCard", e);
      }
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      Lits lits0 = new Lits();
      assertNotNull(lits0);
      assertEquals(0, lits0.nVars());
      assertEquals(0, lits0.realnVars());
      
      int int0 = lits0.getFromPool(2577);
      assertEquals(2577, lits0.nVars());
      assertEquals(1, lits0.realnVars());
      assertEquals(5154, int0);
      
      SearchParams searchParams0 = new SearchParams();
      assertNotNull(searchParams0);
      assertEquals(0.95, searchParams0.getVarDecay(), 0.01);
      assertEquals(0.999, searchParams0.getClaDecay(), 0.01);
      assertEquals(100, searchParams0.getInitConflictBound());
      assertEquals(1.5, searchParams0.getConflictBoundIncFactor(), 0.01);
      
      Glucose21Restarts glucose21Restarts0 = new Glucose21Restarts();
      assertNotNull(glucose21Restarts0);
      assertEquals(0L, glucose21Restarts0.nextRestartNumberOfConflict());
      assertEquals("Glucose 2.1 dynamic restart strategy", glucose21Restarts0.toString());
      
      VecInt vecInt0 = new VecInt(8, 5154);
      assertNotNull(vecInt0);
      assertFalse(vecInt0.isEmpty());
      assertEquals(8, vecInt0.size());
      assertEquals(5154, vecInt0.last());
      
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(lits0, vecInt0, false, (-1641));
      assertNotNull(maxWatchCard0);
      assertEquals(2577, lits0.nVars());
      assertEquals(1, lits0.realnVars());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      assertEquals(1649, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertEquals(8, maxWatchCard0.size());
      assertTrue(maxWatchCard0.locked());
      assertFalse(maxWatchCard0.learnt());
      assertFalse(maxWatchCard0.simplify());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      
      PercentLengthLearning<MixedDataStructureDanielWL> percentLengthLearning0 = new PercentLengthLearning<MixedDataStructureDanielWL>();
      assertNotNull(percentLengthLearning0);
      assertEquals(10, percentLengthLearning0.getLimit());
      
      MixedDataStructureDanielWL mixedDataStructureDanielWL0 = new MixedDataStructureDanielWL();
      assertNotNull(mixedDataStructureDanielWL0);
      
      PositiveLiteralSelectionStrategy positiveLiteralSelectionStrategy0 = new PositiveLiteralSelectionStrategy();
      assertNotNull(positiveLiteralSelectionStrategy0);
      assertEquals("positive phase selection", positiveLiteralSelectionStrategy0.toString());
      
      VarOrderHeap varOrderHeap0 = new VarOrderHeap(positiveLiteralSelectionStrategy0);
      assertNotNull(varOrderHeap0);
      assertEquals("positive phase selection", positiveLiteralSelectionStrategy0.toString());
      assertEquals(0, varOrderHeap0.numberOfInterestingVariables());
      
      TabuListDecorator tabuListDecorator0 = new TabuListDecorator(varOrderHeap0);
      assertNotNull(tabuListDecorator0);
      assertEquals("positive phase selection", positiveLiteralSelectionStrategy0.toString());
      assertEquals(0, varOrderHeap0.numberOfInterestingVariables());
      
      Solver<MixedDataStructureDanielWL> solver0 = new Solver<MixedDataStructureDanielWL>(percentLengthLearning0, mixedDataStructureDanielWL0, searchParams0, tabuListDecorator0, glucose21Restarts0);
      assertNotNull(solver0);
      assertEquals(0.95, searchParams0.getVarDecay(), 0.01);
      assertEquals(0.999, searchParams0.getClaDecay(), 0.01);
      assertEquals(100, searchParams0.getInitConflictBound());
      assertEquals(1.5, searchParams0.getConflictBoundIncFactor(), 0.01);
      assertEquals(0L, glucose21Restarts0.nextRestartNumberOfConflict());
      assertEquals("Glucose 2.1 dynamic restart strategy", glucose21Restarts0.toString());
      assertEquals(10, percentLengthLearning0.getLimit());
      assertEquals("positive phase selection", positiveLiteralSelectionStrategy0.toString());
      assertEquals(0, varOrderHeap0.numberOfInterestingVariables());
      assertEquals(0, solver0.realNumberOfVariables());
      assertEquals(0, solver0.currentDecisionLevel());
      assertEquals(0, solver0.getPropagationLevel());
      assertFalse(solver0.isVerbose());
      assertEquals(0, solver0.nConstraints());
      assertFalse(solver0.isSolverKeptHot());
      assertEquals(0, solver0.nVars());
      assertEquals(2147483, solver0.getTimeout());
      assertEquals(0, solver0.decisionLevel());
      assertFalse(solver0.isDBSimplificationAllowed());
      assertEquals("c ", solver0.getLogPrefix());
      
      // Undeclared exception!
      try { 
        maxWatchCard0.assertConstraint(solver0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 5154
         //
         verifyException("org.sat4j.minisat.constraints.cnf.Lits", e);
      }
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      CardinalityDataStructure cardinalityDataStructure0 = new CardinalityDataStructure();
      assertNotNull(cardinalityDataStructure0);
      
      ILits iLits0 = cardinalityDataStructure0.getVocabulary();
      assertNotNull(iLits0);
      assertEquals(0, iLits0.nVars());
      assertEquals(0, iLits0.realnVars());
      
      VecInt vecInt0 = new VecInt(1);
      assertNotNull(vecInt0);
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      
      int int0 = iLits0.getFromPool(16384);
      assertEquals(1, iLits0.realnVars());
      assertEquals(16384, iLits0.nVars());
      assertEquals(32768, int0);
      
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(iLits0, vecInt0, false, 1);
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      CardinalityDataStructure cardinalityDataStructure0 = new CardinalityDataStructure();
      assertNotNull(cardinalityDataStructure0);
      
      ILits iLits0 = cardinalityDataStructure0.getVocabulary();
      assertNotNull(iLits0);
      assertEquals(0, iLits0.nVars());
      assertEquals(0, iLits0.realnVars());
      
      IVecInt iVecInt0 = VecInt.EMPTY;
      assertNotNull(iVecInt0);
      assertTrue(iVecInt0.isEmpty());
      assertEquals(0, iVecInt0.size());
      
      ReadOnlyVecInt readOnlyVecInt0 = new ReadOnlyVecInt(iVecInt0);
      assertNotNull(readOnlyVecInt0);
      assertTrue(iVecInt0.isEmpty());
      assertEquals(0, iVecInt0.size());
      assertTrue(readOnlyVecInt0.isEmpty());
      assertEquals(0, readOnlyVecInt0.size());
      
      MaxWatchCard maxWatchCard0 = null;
      try {
        maxWatchCard0 = new MaxWatchCard(iLits0, readOnlyVecInt0, false, 1);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.sat4j.core.ReadOnlyVecInt", e);
      }
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      Lits lits0 = new Lits();
      assertNotNull(lits0);
      assertEquals(0, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      
      VecInt vecInt0 = new VecInt(47);
      assertNotNull(vecInt0);
      assertEquals(0, vecInt0.size());
      assertTrue(vecInt0.isEmpty());
      
      IVecInt iVecInt0 = vecInt0.pop();
      assertNotNull(iVecInt0);
      assertFalse(vecInt0.isEmpty());
      assertEquals((-1), vecInt0.size());
      assertEquals((-1), iVecInt0.size());
      assertFalse(iVecInt0.isEmpty());
      assertSame(vecInt0, iVecInt0);
      assertSame(iVecInt0, vecInt0);
      
      MaxWatchCard maxWatchCard0 = null;
      try {
        maxWatchCard0 = new MaxWatchCard(lits0, iVecInt0, true, 1);
        fail("Expecting exception: NegativeArraySizeException");
      
      } catch(NegativeArraySizeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.sat4j.minisat.constraints.card.MaxWatchCard", e);
      }
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      Lits lits0 = new Lits();
      assertNotNull(lits0);
      assertEquals(0, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      
      VecInt vecInt0 = new VecInt(1049, 9970);
      assertNotNull(vecInt0);
      assertEquals(9970, vecInt0.last());
      assertFalse(vecInt0.isEmpty());
      assertEquals(1049, vecInt0.size());
      
      MaxWatchCard maxWatchCard0 = null;
      try {
        maxWatchCard0 = new MaxWatchCard(lits0, vecInt0, false, (-144));
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      CardinalityDataStructure cardinalityDataStructure0 = new CardinalityDataStructure();
      assertNotNull(cardinalityDataStructure0);
      
      ILits iLits0 = cardinalityDataStructure0.getVocabulary();
      assertNotNull(iLits0);
      assertEquals(0, iLits0.realnVars());
      assertEquals(0, iLits0.nVars());
      
      VecInt vecInt0 = new VecInt(1);
      assertNotNull(vecInt0);
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(iLits0, vecInt0, true, 1);
      assertNotNull(maxWatchCard0);
      assertEquals(0, iLits0.realnVars());
      assertEquals(0, iLits0.nVars());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      assertFalse(maxWatchCard0.simplify());
      assertTrue(maxWatchCard0.locked());
      assertFalse(maxWatchCard0.learnt());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertEquals(1, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertEquals(0, maxWatchCard0.size());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      
      maxWatchCard0.normalize();
      assertEquals(0, iLits0.realnVars());
      assertEquals(0, iLits0.nVars());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      assertFalse(maxWatchCard0.simplify());
      assertTrue(maxWatchCard0.locked());
      assertFalse(maxWatchCard0.learnt());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertEquals(1, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertEquals(0, maxWatchCard0.size());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      Lits lits0 = new Lits();
      assertNotNull(lits0);
      assertEquals(0, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      
      VecInt vecInt0 = new VecInt(2120, 0);
      assertNotNull(vecInt0);
      assertEquals(0, vecInt0.last());
      assertEquals(2120, vecInt0.size());
      assertFalse(vecInt0.isEmpty());
      
      int int0 = lits0.getFromPool(0);
      assertEquals(1, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      assertEquals(0, int0);
      
      DotSearchTracing<String> dotSearchTracing0 = new DotSearchTracing<String>("0");
      assertNotNull(dotSearchTracing0);
      
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(lits0, vecInt0, true, 2120);
      assertNotNull(maxWatchCard0);
      assertEquals(1, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      assertTrue(maxWatchCard0.locked());
      assertFalse(maxWatchCard0.simplify());
      assertEquals(2120, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertEquals(2120, maxWatchCard0.size());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertFalse(maxWatchCard0.learnt());
      
      String string0 = maxWatchCard0.toString((VarMapper) dotSearchTracing0);
      assertNotNull(string0);
      assertEquals(1, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      assertTrue(maxWatchCard0.locked());
      assertFalse(maxWatchCard0.simplify());
      assertEquals(2120, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertEquals(2120, maxWatchCard0.size());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertFalse(maxWatchCard0.learnt());
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      Lits lits0 = new Lits();
      assertNotNull(lits0);
      assertEquals(0, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      
      VecInt vecInt0 = new VecInt(1309);
      assertNotNull(vecInt0);
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(lits0, vecInt0, false, 1309);
      assertNotNull(maxWatchCard0);
      assertEquals(0, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      assertFalse(maxWatchCard0.simplify());
      assertTrue(maxWatchCard0.locked());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertEquals(0, maxWatchCard0.size());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertFalse(maxWatchCard0.learnt());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertEquals((-1309), maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      
      DotSearchTracing<String> dotSearchTracing0 = new DotSearchTracing<String>("");
      assertNotNull(dotSearchTracing0);
      
      String string0 = maxWatchCard0.toString((VarMapper) dotSearchTracing0);
      assertNotNull(string0);
      assertEquals(0, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      assertFalse(maxWatchCard0.simplify());
      assertTrue(maxWatchCard0.locked());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertEquals(0, maxWatchCard0.size());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertFalse(maxWatchCard0.learnt());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertEquals((-1309), maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertEquals("", string0);
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      Lits lits0 = new Lits();
      assertNotNull(lits0);
      assertEquals(0, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      
      VecInt vecInt0 = new VecInt(2120, 0);
      assertNotNull(vecInt0);
      assertFalse(vecInt0.isEmpty());
      assertEquals(0, vecInt0.last());
      assertEquals(2120, vecInt0.size());
      
      int int0 = lits0.getFromPool(0);
      assertEquals(1, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      assertEquals(0, int0);
      
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(lits0, vecInt0, false, 0);
      assertNotNull(maxWatchCard0);
      assertEquals(1, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      assertEquals(0, vecInt0.size());
      assertTrue(vecInt0.isEmpty());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertEquals(2120, maxWatchCard0.size());
      assertTrue(maxWatchCard0.locked());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertFalse(maxWatchCard0.simplify());
      assertEquals(2120, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertFalse(maxWatchCard0.learnt());
      
      // Undeclared exception!
      try { 
        maxWatchCard0.assertConstraint((UnitPropagationListener) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.sat4j.minisat.constraints.card.MaxWatchCard", e);
      }
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      Lits lits0 = new Lits();
      assertNotNull(lits0);
      assertEquals(0, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      
      VecInt vecInt0 = new VecInt(2120, 0);
      assertNotNull(vecInt0);
      assertFalse(vecInt0.isEmpty());
      assertEquals(0, vecInt0.last());
      assertEquals(2120, vecInt0.size());
      
      int int0 = lits0.getFromPool(0);
      assertEquals(1, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      assertEquals(0, int0);
      
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(lits0, vecInt0, false, 0);
      assertNotNull(maxWatchCard0);
      assertEquals(1, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      assertEquals(0, vecInt0.size());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertTrue(maxWatchCard0.locked());
      assertFalse(maxWatchCard0.learnt());
      assertEquals(2120, maxWatchCard0.size());
      assertFalse(maxWatchCard0.simplify());
      assertEquals(2120, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      
      String string0 = maxWatchCard0.toString();
      assertNotNull(string0);
      assertEquals(1, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      assertEquals(0, vecInt0.size());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertTrue(maxWatchCard0.locked());
      assertFalse(maxWatchCard0.learnt());
      assertEquals(2120, maxWatchCard0.size());
      assertFalse(maxWatchCard0.simplify());
      assertEquals(2120, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      Lits lits0 = new Lits();
      assertNotNull(lits0);
      assertEquals(0, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      
      VecInt vecInt0 = new VecInt(1344);
      assertNotNull(vecInt0);
      assertEquals(0, vecInt0.size());
      assertTrue(vecInt0.isEmpty());
      
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(lits0, vecInt0, false, 0);
      assertNotNull(maxWatchCard0);
      assertEquals(0, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      assertEquals(0, vecInt0.size());
      assertTrue(vecInt0.isEmpty());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertEquals(0, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertFalse(maxWatchCard0.learnt());
      assertEquals(0, maxWatchCard0.size());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertFalse(maxWatchCard0.simplify());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertTrue(maxWatchCard0.locked());
      
      String string0 = maxWatchCard0.toString();
      assertNotNull(string0);
      assertEquals(0, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      assertEquals(0, vecInt0.size());
      assertTrue(vecInt0.isEmpty());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertEquals(0, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertFalse(maxWatchCard0.learnt());
      assertEquals(0, maxWatchCard0.size());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertFalse(maxWatchCard0.simplify());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertTrue(maxWatchCard0.locked());
      assertEquals("", string0);
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      Lits lits0 = new Lits();
      assertNotNull(lits0);
      assertEquals(0, lits0.nVars());
      assertEquals(0, lits0.realnVars());
      
      VecInt vecInt0 = new VecInt(2120, 0);
      assertNotNull(vecInt0);
      assertEquals(0, vecInt0.last());
      assertEquals(2120, vecInt0.size());
      assertFalse(vecInt0.isEmpty());
      
      int int0 = lits0.getFromPool(0);
      assertEquals(0, lits0.nVars());
      assertEquals(1, lits0.realnVars());
      assertEquals(0, int0);
      
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(lits0, vecInt0, true, 2120);
      assertNotNull(maxWatchCard0);
      assertEquals(0, lits0.nVars());
      assertEquals(1, lits0.realnVars());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      assertFalse(maxWatchCard0.learnt());
      assertTrue(maxWatchCard0.locked());
      assertEquals(2120, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertEquals(2120, maxWatchCard0.size());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertFalse(maxWatchCard0.simplify());
      
      boolean boolean0 = maxWatchCard0.simplify();
      assertEquals(0, lits0.nVars());
      assertEquals(1, lits0.realnVars());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      assertFalse(maxWatchCard0.learnt());
      assertTrue(maxWatchCard0.locked());
      assertEquals(2120, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertEquals(2120, maxWatchCard0.size());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertFalse(maxWatchCard0.simplify());
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      Lits lits0 = new Lits();
      assertNotNull(lits0);
      assertEquals(0, lits0.nVars());
      assertEquals(0, lits0.realnVars());
      
      VecInt vecInt0 = new VecInt(2120, 0);
      assertNotNull(vecInt0);
      assertFalse(vecInt0.isEmpty());
      assertEquals(2120, vecInt0.size());
      assertEquals(0, vecInt0.last());
      
      int int0 = lits0.getFromPool(0);
      assertEquals(0, lits0.nVars());
      assertEquals(1, lits0.realnVars());
      assertEquals(0, int0);
      
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(lits0, vecInt0, true, 0);
      assertNotNull(maxWatchCard0);
      assertEquals(0, lits0.nVars());
      assertEquals(1, lits0.realnVars());
      assertEquals(0, vecInt0.size());
      assertTrue(vecInt0.isEmpty());
      assertFalse(maxWatchCard0.simplify());
      assertEquals(2120, maxWatchCard0.size());
      assertFalse(maxWatchCard0.learnt());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertEquals(0, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertTrue(maxWatchCard0.locked());
      
      boolean boolean0 = maxWatchCard0.simplify();
      assertEquals(0, lits0.nVars());
      assertEquals(1, lits0.realnVars());
      assertEquals(0, vecInt0.size());
      assertTrue(vecInt0.isEmpty());
      assertEquals(2120, maxWatchCard0.size());
      assertFalse(maxWatchCard0.learnt());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertEquals(0, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertTrue(maxWatchCard0.locked());
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      Lits lits0 = new Lits();
      assertNotNull(lits0);
      assertEquals(0, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      
      VecInt vecInt0 = new VecInt(0, 0);
      assertNotNull(vecInt0);
      assertEquals(0, vecInt0.size());
      assertTrue(vecInt0.isEmpty());
      
      int int0 = lits0.getFromPool(0);
      assertEquals(1, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      assertEquals(0, int0);
      
      SearchParams searchParams0 = new SearchParams(0);
      assertNotNull(searchParams0);
      assertEquals(1.5, searchParams0.getConflictBoundIncFactor(), 0.01);
      assertEquals(0, searchParams0.getInitConflictBound());
      assertEquals(0.95, searchParams0.getVarDecay(), 0.01);
      assertEquals(0.999, searchParams0.getClaDecay(), 0.01);
      
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(lits0, vecInt0, true, 0);
      assertNotNull(maxWatchCard0);
      assertEquals(1, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      assertEquals(0, vecInt0.size());
      assertTrue(vecInt0.isEmpty());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertEquals(0, maxWatchCard0.size());
      assertFalse(maxWatchCard0.simplify());
      assertFalse(maxWatchCard0.learnt());
      assertTrue(maxWatchCard0.locked());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertEquals(0, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      
      MiniSATLearning<MixedDataStructureDanielWL> miniSATLearning0 = new MiniSATLearning<MixedDataStructureDanielWL>();
      assertNotNull(miniSATLearning0);
      assertEquals("Learn all clauses as in MiniSAT", miniSATLearning0.toString());
      
      MixedDataStructureDanielWL mixedDataStructureDanielWL0 = new MixedDataStructureDanielWL();
      assertNotNull(mixedDataStructureDanielWL0);
      
      PureOrder pureOrder0 = new PureOrder(0);
      assertNotNull(pureOrder0);
      assertEquals("tries to first branch on a single phase watched unassigned variable (pure literal if using a CB data structure) else VSIDS from MiniSAT", pureOrder0.toString());
      assertEquals(0, pureOrder0.getPeriod());
      assertEquals(0, pureOrder0.numberOfInterestingVariables());
      
      LubyRestarts lubyRestarts0 = new LubyRestarts();
      assertNotNull(lubyRestarts0);
      assertEquals(32, LubyRestarts.DEFAULT_LUBY_FACTOR);
      assertTrue(lubyRestarts0.shouldRestart());
      assertEquals(0L, lubyRestarts0.nextRestartNumberOfConflict());
      assertEquals(1, lubyRestarts0.luby());
      assertEquals(32, lubyRestarts0.getFactor());
      
      Solver<MixedDataStructureDanielWL> solver0 = new Solver<MixedDataStructureDanielWL>(miniSATLearning0, mixedDataStructureDanielWL0, searchParams0, pureOrder0, lubyRestarts0);
      assertNotNull(solver0);
      assertEquals(32, LubyRestarts.DEFAULT_LUBY_FACTOR);
      assertEquals(1.5, searchParams0.getConflictBoundIncFactor(), 0.01);
      assertEquals(0, searchParams0.getInitConflictBound());
      assertEquals(0.95, searchParams0.getVarDecay(), 0.01);
      assertEquals(0.999, searchParams0.getClaDecay(), 0.01);
      assertEquals("Learn all clauses as in MiniSAT", miniSATLearning0.toString());
      assertEquals("tries to first branch on a single phase watched unassigned variable (pure literal if using a CB data structure) else VSIDS from MiniSAT", pureOrder0.toString());
      assertEquals(0, pureOrder0.getPeriod());
      assertEquals(0, pureOrder0.numberOfInterestingVariables());
      assertTrue(lubyRestarts0.shouldRestart());
      assertEquals(0L, lubyRestarts0.nextRestartNumberOfConflict());
      assertEquals(1, lubyRestarts0.luby());
      assertEquals(32, lubyRestarts0.getFactor());
      assertEquals(0, solver0.decisionLevel());
      assertEquals(0, solver0.currentDecisionLevel());
      assertEquals(0, solver0.getPropagationLevel());
      assertEquals(0, solver0.realNumberOfVariables());
      assertFalse(solver0.isVerbose());
      assertEquals(0, solver0.nConstraints());
      assertFalse(solver0.isSolverKeptHot());
      assertEquals(0, solver0.nVars());
      assertEquals(2147483, solver0.getTimeout());
      assertFalse(solver0.isDBSimplificationAllowed());
      assertEquals("c ", solver0.getLogPrefix());
      
      boolean boolean0 = maxWatchCard0.propagate(solver0, 0);
      assertEquals(32, LubyRestarts.DEFAULT_LUBY_FACTOR);
      assertEquals(1, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      assertEquals(0, vecInt0.size());
      assertTrue(vecInt0.isEmpty());
      assertEquals(1.5, searchParams0.getConflictBoundIncFactor(), 0.01);
      assertEquals(0, searchParams0.getInitConflictBound());
      assertEquals(0.95, searchParams0.getVarDecay(), 0.01);
      assertEquals(0.999, searchParams0.getClaDecay(), 0.01);
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertEquals(0, maxWatchCard0.size());
      assertFalse(maxWatchCard0.simplify());
      assertFalse(maxWatchCard0.learnt());
      assertTrue(maxWatchCard0.locked());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertEquals(0, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertEquals("Learn all clauses as in MiniSAT", miniSATLearning0.toString());
      assertEquals("tries to first branch on a single phase watched unassigned variable (pure literal if using a CB data structure) else VSIDS from MiniSAT", pureOrder0.toString());
      assertEquals(0, pureOrder0.getPeriod());
      assertEquals(0, pureOrder0.numberOfInterestingVariables());
      assertTrue(lubyRestarts0.shouldRestart());
      assertEquals(0L, lubyRestarts0.nextRestartNumberOfConflict());
      assertEquals(1, lubyRestarts0.luby());
      assertEquals(32, lubyRestarts0.getFactor());
      assertEquals(0, solver0.decisionLevel());
      assertEquals(0, solver0.currentDecisionLevel());
      assertEquals(0, solver0.getPropagationLevel());
      assertEquals(0, solver0.realNumberOfVariables());
      assertFalse(solver0.isVerbose());
      assertEquals(0, solver0.nConstraints());
      assertFalse(solver0.isSolverKeptHot());
      assertEquals(0, solver0.nVars());
      assertEquals(2147483, solver0.getTimeout());
      assertFalse(solver0.isDBSimplificationAllowed());
      assertEquals("c ", solver0.getLogPrefix());
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      CardinalityDataStructure cardinalityDataStructure0 = new CardinalityDataStructure();
      assertNotNull(cardinalityDataStructure0);
      
      ILits iLits0 = cardinalityDataStructure0.getVocabulary();
      assertNotNull(iLits0);
      assertEquals(0, iLits0.nVars());
      assertEquals(0, iLits0.realnVars());
      
      VecInt vecInt0 = new VecInt(6);
      assertNotNull(vecInt0);
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(iLits0, vecInt0, true, 64);
      assertNotNull(maxWatchCard0);
      assertEquals(0, iLits0.nVars());
      assertEquals(0, iLits0.realnVars());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertEquals(64, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertFalse(maxWatchCard0.learnt());
      assertEquals(0, maxWatchCard0.size());
      assertTrue(maxWatchCard0.locked());
      assertFalse(maxWatchCard0.simplify());
      
      int int0 = iLits0.getFromPool(32);
      assertEquals(32, iLits0.nVars());
      assertEquals(1, iLits0.realnVars());
      assertEquals(64, int0);
      
      PureOrder pureOrder0 = new PureOrder();
      assertNotNull(pureOrder0);
      assertEquals(0, pureOrder0.numberOfInterestingVariables());
      assertEquals(20, pureOrder0.getPeriod());
      assertEquals("tries to first branch on a single phase watched unassigned variable (pure literal if using a CB data structure) else VSIDS from MiniSAT", pureOrder0.toString());
      
      MiniSATRestarts miniSATRestarts0 = new MiniSATRestarts();
      assertNotNull(miniSATRestarts0);
      assertTrue(miniSATRestarts0.shouldRestart());
      assertEquals("MiniSAT restarts strategy", miniSATRestarts0.toString());
      assertEquals(0L, miniSATRestarts0.nextRestartNumberOfConflict());
      
      ClauseOnlyLearning<MixedDataStructureDanielWL> clauseOnlyLearning0 = new ClauseOnlyLearning<MixedDataStructureDanielWL>();
      assertNotNull(clauseOnlyLearning0);
      assertEquals("Limit learning to clauses using watched literals only", clauseOnlyLearning0.toString());
      
      MixedDataStructureDanielWL mixedDataStructureDanielWL0 = new MixedDataStructureDanielWL();
      assertNotNull(mixedDataStructureDanielWL0);
      
      Solver<MixedDataStructureDanielWL> solver0 = new Solver<MixedDataStructureDanielWL>(clauseOnlyLearning0, mixedDataStructureDanielWL0, pureOrder0, miniSATRestarts0);
      assertNotNull(solver0);
      assertEquals(0, pureOrder0.numberOfInterestingVariables());
      assertEquals(20, pureOrder0.getPeriod());
      assertEquals("tries to first branch on a single phase watched unassigned variable (pure literal if using a CB data structure) else VSIDS from MiniSAT", pureOrder0.toString());
      assertTrue(miniSATRestarts0.shouldRestart());
      assertEquals("MiniSAT restarts strategy", miniSATRestarts0.toString());
      assertEquals(0L, miniSATRestarts0.nextRestartNumberOfConflict());
      assertEquals("Limit learning to clauses using watched literals only", clauseOnlyLearning0.toString());
      assertFalse(solver0.isDBSimplificationAllowed());
      assertFalse(solver0.isSolverKeptHot());
      assertEquals(0, solver0.nVars());
      assertEquals(2147483, solver0.getTimeout());
      assertEquals(0, solver0.decisionLevel());
      assertEquals(0, solver0.currentDecisionLevel());
      assertEquals(0, solver0.getPropagationLevel());
      assertEquals(0, solver0.realNumberOfVariables());
      assertFalse(solver0.isVerbose());
      assertEquals(0, solver0.nConstraints());
      assertEquals("c ", solver0.getLogPrefix());
      
      boolean boolean0 = maxWatchCard0.propagate(solver0, 64);
      assertEquals(32, iLits0.nVars());
      assertEquals(1, iLits0.realnVars());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      assertFalse(maxWatchCard0.canBePropagatedMultipleTimes());
      assertEquals(64, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertTrue(maxWatchCard0.canBeSatisfiedByCountingLiterals());
      assertEquals(0.0, maxWatchCard0.getActivity(), 0.01);
      assertFalse(maxWatchCard0.learnt());
      assertEquals(0, maxWatchCard0.size());
      assertTrue(maxWatchCard0.locked());
      assertFalse(maxWatchCard0.simplify());
      assertEquals(0, pureOrder0.numberOfInterestingVariables());
      assertEquals(20, pureOrder0.getPeriod());
      assertEquals("tries to first branch on a single phase watched unassigned variable (pure literal if using a CB data structure) else VSIDS from MiniSAT", pureOrder0.toString());
      assertTrue(miniSATRestarts0.shouldRestart());
      assertEquals("MiniSAT restarts strategy", miniSATRestarts0.toString());
      assertEquals(0L, miniSATRestarts0.nextRestartNumberOfConflict());
      assertEquals("Limit learning to clauses using watched literals only", clauseOnlyLearning0.toString());
      assertFalse(solver0.isDBSimplificationAllowed());
      assertFalse(solver0.isSolverKeptHot());
      assertEquals(0, solver0.nVars());
      assertEquals(2147483, solver0.getTimeout());
      assertEquals(0, solver0.decisionLevel());
      assertEquals(0, solver0.currentDecisionLevel());
      assertEquals(0, solver0.getPropagationLevel());
      assertEquals(0, solver0.realNumberOfVariables());
      assertFalse(solver0.isVerbose());
      assertEquals(0, solver0.nConstraints());
      assertEquals("c ", solver0.getLogPrefix());
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test37()  throws Throwable  {
      Lits lits0 = new Lits();
      assertNotNull(lits0);
      assertEquals(0, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      
      VecInt vecInt0 = new VecInt(2120, 0);
      assertNotNull(vecInt0);
      assertEquals(2120, vecInt0.size());
      assertEquals(0, vecInt0.last());
      assertFalse(vecInt0.isEmpty());
      
      int int0 = lits0.getFromPool(0);
      assertEquals(1, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      assertEquals(0, int0);
      
      ClauseOnlyLearning<MixedDataStructureDanielWL> clauseOnlyLearning0 = new ClauseOnlyLearning<MixedDataStructureDanielWL>();
      assertNotNull(clauseOnlyLearning0);
      assertEquals("Limit learning to clauses using watched literals only", clauseOnlyLearning0.toString());
      
      MixedDataStructureDanielWL mixedDataStructureDanielWL0 = new MixedDataStructureDanielWL();
      assertNotNull(mixedDataStructureDanielWL0);
      
      PureOrder pureOrder0 = new PureOrder();
      assertNotNull(pureOrder0);
      assertEquals(20, pureOrder0.getPeriod());
      assertEquals("tries to first branch on a single phase watched unassigned variable (pure literal if using a CB data structure) else VSIDS from MiniSAT", pureOrder0.toString());
      assertEquals(0, pureOrder0.numberOfInterestingVariables());
      
      Glucose21Restarts glucose21Restarts0 = new Glucose21Restarts();
      assertNotNull(glucose21Restarts0);
      assertEquals(0L, glucose21Restarts0.nextRestartNumberOfConflict());
      assertEquals("Glucose 2.1 dynamic restart strategy", glucose21Restarts0.toString());
      
      Solver<MixedDataStructureDanielWL> solver0 = new Solver<MixedDataStructureDanielWL>(clauseOnlyLearning0, mixedDataStructureDanielWL0, pureOrder0, glucose21Restarts0);
      assertNotNull(solver0);
      assertEquals("Limit learning to clauses using watched literals only", clauseOnlyLearning0.toString());
      assertEquals(20, pureOrder0.getPeriod());
      assertEquals("tries to first branch on a single phase watched unassigned variable (pure literal if using a CB data structure) else VSIDS from MiniSAT", pureOrder0.toString());
      assertEquals(0, pureOrder0.numberOfInterestingVariables());
      assertEquals(0L, glucose21Restarts0.nextRestartNumberOfConflict());
      assertEquals("Glucose 2.1 dynamic restart strategy", glucose21Restarts0.toString());
      assertEquals(0, solver0.nConstraints());
      assertEquals(2147483, solver0.getTimeout());
      assertFalse(solver0.isSolverKeptHot());
      assertEquals(0, solver0.currentDecisionLevel());
      assertFalse(solver0.isVerbose());
      assertEquals(0, solver0.getPropagationLevel());
      assertEquals(0, solver0.nVars());
      assertEquals("c ", solver0.getLogPrefix());
      assertFalse(solver0.isDBSimplificationAllowed());
      assertEquals(0, solver0.decisionLevel());
      assertEquals(0, solver0.realNumberOfVariables());
      
      Constr constr0 = MaxWatchCard.maxWatchCardNew(solver0, lits0, vecInt0, false, 1);
      assertNotNull(constr0);
      assertEquals(1, lits0.realnVars());
      assertEquals(0, lits0.nVars());
      assertTrue(vecInt0.isEmpty());
      assertEquals(0, vecInt0.size());
      assertEquals("Limit learning to clauses using watched literals only", clauseOnlyLearning0.toString());
      assertEquals(20, pureOrder0.getPeriod());
      assertEquals("tries to first branch on a single phase watched unassigned variable (pure literal if using a CB data structure) else VSIDS from MiniSAT", pureOrder0.toString());
      assertEquals(0, pureOrder0.numberOfInterestingVariables());
      assertEquals(0L, glucose21Restarts0.nextRestartNumberOfConflict());
      assertEquals("Glucose 2.1 dynamic restart strategy", glucose21Restarts0.toString());
      assertEquals(0, solver0.nConstraints());
      assertEquals(2147483, solver0.getTimeout());
      assertFalse(solver0.isSolverKeptHot());
      assertEquals(0, solver0.currentDecisionLevel());
      assertFalse(solver0.isVerbose());
      assertEquals(0, solver0.getPropagationLevel());
      assertEquals(0, solver0.nVars());
      assertEquals("c ", solver0.getLogPrefix());
      assertFalse(solver0.isDBSimplificationAllowed());
      assertEquals(0, solver0.decisionLevel());
      assertEquals(0, solver0.realNumberOfVariables());
      assertFalse(constr0.canBePropagatedMultipleTimes());
      assertEquals(0.0, constr0.getActivity(), 0.01);
      assertFalse(constr0.learnt());
      assertEquals(2119, constr0.requiredNumberOfSatisfiedLiterals());
      assertFalse(constr0.simplify());
      assertTrue(constr0.canBeSatisfiedByCountingLiterals());
      assertEquals(2120, constr0.size());
      assertTrue(constr0.locked());
  }

  @Test(timeout = 4000)
  public void test38()  throws Throwable  {
      Lits lits0 = new Lits();
      assertNotNull(lits0);
      assertEquals(0, lits0.nVars());
      assertEquals(0, lits0.realnVars());
      
      VecInt vecInt0 = new VecInt(2120, 0);
      assertNotNull(vecInt0);
      assertFalse(vecInt0.isEmpty());
      assertEquals(0, vecInt0.last());
      assertEquals(2120, vecInt0.size());
      
      int int0 = lits0.getFromPool(0);
      assertEquals(0, lits0.nVars());
      assertEquals(1, lits0.realnVars());
      assertEquals(0, int0);
      
      ClauseOnlyLearning<MixedDataStructureDanielWL> clauseOnlyLearning0 = new ClauseOnlyLearning<MixedDataStructureDanielWL>();
      assertNotNull(clauseOnlyLearning0);
      assertEquals("Limit learning to clauses using watched literals only", clauseOnlyLearning0.toString());
      
      MixedDataStructureDanielWL mixedDataStructureDanielWL0 = new MixedDataStructureDanielWL();
      assertNotNull(mixedDataStructureDanielWL0);
      
      PureOrder pureOrder0 = new PureOrder(0);
      assertNotNull(pureOrder0);
      assertEquals(0, pureOrder0.numberOfInterestingVariables());
      assertEquals("tries to first branch on a single phase watched unassigned variable (pure literal if using a CB data structure) else VSIDS from MiniSAT", pureOrder0.toString());
      assertEquals(0, pureOrder0.getPeriod());
      
      Glucose21Restarts glucose21Restarts0 = new Glucose21Restarts();
      assertNotNull(glucose21Restarts0);
      assertEquals(0L, glucose21Restarts0.nextRestartNumberOfConflict());
      assertEquals("Glucose 2.1 dynamic restart strategy", glucose21Restarts0.toString());
      
      Solver<MixedDataStructureDanielWL> solver0 = new Solver<MixedDataStructureDanielWL>(clauseOnlyLearning0, mixedDataStructureDanielWL0, pureOrder0, glucose21Restarts0);
      assertNotNull(solver0);
      assertEquals("Limit learning to clauses using watched literals only", clauseOnlyLearning0.toString());
      assertEquals(0, pureOrder0.numberOfInterestingVariables());
      assertEquals("tries to first branch on a single phase watched unassigned variable (pure literal if using a CB data structure) else VSIDS from MiniSAT", pureOrder0.toString());
      assertEquals(0, pureOrder0.getPeriod());
      assertEquals(0L, glucose21Restarts0.nextRestartNumberOfConflict());
      assertEquals("Glucose 2.1 dynamic restart strategy", glucose21Restarts0.toString());
      assertEquals(0, solver0.getPropagationLevel());
      assertEquals(0, solver0.realNumberOfVariables());
      assertFalse(solver0.isVerbose());
      assertEquals(0, solver0.decisionLevel());
      assertEquals(0, solver0.currentDecisionLevel());
      assertFalse(solver0.isSolverKeptHot());
      assertEquals(0, solver0.nConstraints());
      assertEquals(2147483, solver0.getTimeout());
      assertEquals(0, solver0.nVars());
      assertFalse(solver0.isDBSimplificationAllowed());
      assertEquals("c ", solver0.getLogPrefix());
      
      Constr constr0 = MaxWatchCard.maxWatchCardNew(solver0, lits0, vecInt0, false, 0);
      assertNull(constr0);
      assertEquals(0, lits0.nVars());
      assertEquals(1, lits0.realnVars());
      assertEquals(0, vecInt0.size());
      assertTrue(vecInt0.isEmpty());
      assertEquals("Limit learning to clauses using watched literals only", clauseOnlyLearning0.toString());
      assertEquals(0, pureOrder0.numberOfInterestingVariables());
      assertEquals("tries to first branch on a single phase watched unassigned variable (pure literal if using a CB data structure) else VSIDS from MiniSAT", pureOrder0.toString());
      assertEquals(0, pureOrder0.getPeriod());
      assertEquals(0L, glucose21Restarts0.nextRestartNumberOfConflict());
      assertEquals("Glucose 2.1 dynamic restart strategy", glucose21Restarts0.toString());
      assertEquals(0, solver0.realNumberOfVariables());
      assertFalse(solver0.isVerbose());
      assertEquals(0, solver0.decisionLevel());
      assertEquals(0, solver0.currentDecisionLevel());
      assertEquals(1, solver0.getPropagationLevel());
      assertFalse(solver0.isSolverKeptHot());
      assertEquals(0, solver0.nConstraints());
      assertEquals(2147483, solver0.getTimeout());
      assertEquals(0, solver0.nVars());
      assertFalse(solver0.isDBSimplificationAllowed());
      assertEquals("c ", solver0.getLogPrefix());
  }

  @Test(timeout = 4000)
  public void test39()  throws Throwable  {
      CardinalityDataStructure cardinalityDataStructure0 = new CardinalityDataStructure();
      ILits iLits0 = cardinalityDataStructure0.getVocabulary();
      VecInt vecInt0 = new VecInt(1);
      SearchParams searchParams0 = new SearchParams(1);
      FixedLengthLearning<MixedDataStructureDanielWL> fixedLengthLearning0 = new FixedLengthLearning<MixedDataStructureDanielWL>();
      MixedDataStructureDanielWL mixedDataStructureDanielWL0 = new MixedDataStructureDanielWL();
      int[] intArray0 = new int[1];
      SubsetVarOrder subsetVarOrder0 = new SubsetVarOrder(intArray0);
      RandomWalkDecorator randomWalkDecorator0 = new RandomWalkDecorator(subsetVarOrder0);
      MiniSATRestarts miniSATRestarts0 = new MiniSATRestarts();
      ILogAble iLogAble0 = ILogAble.CONSOLE;
      Solver<MixedDataStructureDanielWL> solver0 = new Solver<MixedDataStructureDanielWL>(fixedLengthLearning0, mixedDataStructureDanielWL0, searchParams0, randomWalkDecorator0, miniSATRestarts0, iLogAble0);
      Constr constr0 = MaxWatchCard.maxWatchCardNew(solver0, iLits0, vecInt0, true, (-887));
      assertNull(constr0);
  }

  @Test(timeout = 4000)
  public void test40()  throws Throwable  {
      CardinalityDataStructure cardinalityDataStructure0 = new CardinalityDataStructure();
      ILits iLits0 = cardinalityDataStructure0.getVocabulary();
      VecInt vecInt0 = new VecInt(1);
      IVecInt iVecInt0 = vecInt0.push(1);
      PureOrder pureOrder0 = new PureOrder();
      ClauseOnlyLearning<MixedDataStructureDanielWL> clauseOnlyLearning0 = new ClauseOnlyLearning<MixedDataStructureDanielWL>();
      MixedDataStructureDanielWL mixedDataStructureDanielWL0 = new MixedDataStructureDanielWL();
      Glucose21Restarts glucose21Restarts0 = new Glucose21Restarts();
      Solver<MixedDataStructureDanielWL> solver0 = new Solver<MixedDataStructureDanielWL>(clauseOnlyLearning0, mixedDataStructureDanielWL0, pureOrder0, glucose21Restarts0);
      MaxWatchCard.maxWatchCardNew(solver0, iLits0, iVecInt0, true, 1);
      assertEquals(1, solver0.getPropagationLevel());
  }

  @Test(timeout = 4000)
  public void test41()  throws Throwable  {
      ActiveLearning<MixedDataStructureDanielWL> activeLearning0 = new ActiveLearning<MixedDataStructureDanielWL>();
      MixedDataStructureDanielWL mixedDataStructureDanielWL0 = new MixedDataStructureDanielWL();
      VarOrderHeap varOrderHeap0 = new VarOrderHeap();
      ArminRestarts arminRestarts0 = new ArminRestarts();
      Solver<MixedDataStructureDanielWL> solver0 = new Solver<MixedDataStructureDanielWL>(activeLearning0, mixedDataStructureDanielWL0, varOrderHeap0, arminRestarts0);
      ILits iLits0 = solver0.getVocabulary();
      VecInt vecInt0 = new VecInt(2);
      try { 
        MaxWatchCard.maxWatchCardNew(solver0, iLits0, vecInt0, false, 2);
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         // Creating trivially inconsistent constraint
         //
         verifyException("org.sat4j.minisat.constraints.card.MaxWatchCard", e);
      }
  }

  @Test(timeout = 4000)
  public void test42()  throws Throwable  {
      CardinalityDataStructure cardinalityDataStructure0 = new CardinalityDataStructure();
      ILits iLits0 = cardinalityDataStructure0.getVocabulary();
      VecInt vecInt0 = new VecInt(1);
      MixedDataStructureDanielWL mixedDataStructureDanielWL0 = new MixedDataStructureDanielWL();
      Glucose21Restarts glucose21Restarts0 = new Glucose21Restarts();
      FixedLengthLearning<MixedDataStructureDanielWL> fixedLengthLearning0 = new FixedLengthLearning<MixedDataStructureDanielWL>(11);
      VarOrderHeap varOrderHeap0 = new VarOrderHeap();
      Solver<MixedDataStructureDanielWL> solver0 = new Solver<MixedDataStructureDanielWL>(fixedLengthLearning0, mixedDataStructureDanielWL0, varOrderHeap0, glucose21Restarts0);
      try { 
        MaxWatchCard.maxWatchCardNew(solver0, iLits0, vecInt0, false, (-1));
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.sat4j.minisat.constraints.card.MaxWatchCard", e);
      }
  }

  @Test(timeout = 4000)
  public void test43()  throws Throwable  {
      Lits lits0 = new Lits();
      VecInt vecInt0 = new VecInt(2120, 0);
      lits0.getFromPool(0);
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(lits0, vecInt0, true, 0);
      maxWatchCard0.calcReason(2120, vecInt0);
      assertTrue(vecInt0.isEmpty());
      assertEquals(2120, maxWatchCard0.size());
  }

  @Test(timeout = 4000)
  public void test44()  throws Throwable  {
      Lits lits0 = new Lits();
      VecInt vecInt0 = new VecInt(1309);
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(lits0, vecInt0, false, 1309);
      double double0 = maxWatchCard0.getActivity();
      assertEquals((-1309), maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertEquals(0.0, double0, 0.01);
  }

  @Test(timeout = 4000)
  public void test45()  throws Throwable  {
      MiniSATLearning<MixedDataStructureDanielWL> miniSATLearning0 = new MiniSATLearning<MixedDataStructureDanielWL>();
      MixedDataStructureDanielWL mixedDataStructureDanielWL0 = new MixedDataStructureDanielWL();
      SearchParams searchParams0 = new SearchParams(0.0, (-2425));
      PureOrder pureOrder0 = new PureOrder();
      MiniSATRestarts miniSATRestarts0 = new MiniSATRestarts();
      Solver<MixedDataStructureDanielWL> solver0 = new Solver<MixedDataStructureDanielWL>(miniSATLearning0, mixedDataStructureDanielWL0, searchParams0, pureOrder0, miniSATRestarts0);
      ILits iLits0 = solver0.getVocabulary();
      IVecInt iVecInt0 = solver0.getOutLearnt();
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(iLits0, iVecInt0, true, (-2425));
      maxWatchCard0.rescaleBy(0.0);
      assertEquals((-2425), maxWatchCard0.requiredNumberOfSatisfiedLiterals());
  }

  @Test(timeout = 4000)
  public void test46()  throws Throwable  {
      CardinalityDataStructure cardinalityDataStructure0 = new CardinalityDataStructure();
      ILits iLits0 = cardinalityDataStructure0.getVocabulary();
      VecInt vecInt0 = new VecInt(1);
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(iLits0, vecInt0, false, 1);
      boolean boolean0 = maxWatchCard0.canBeSatisfiedByCountingLiterals();
      assertTrue(boolean0);
      assertEquals((-1), maxWatchCard0.requiredNumberOfSatisfiedLiterals());
  }

  @Test(timeout = 4000)
  public void test47()  throws Throwable  {
      CardinalityDataStructure cardinalityDataStructure0 = new CardinalityDataStructure();
      ILits iLits0 = cardinalityDataStructure0.getVocabulary();
      VecInt vecInt0 = new VecInt(1);
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(iLits0, vecInt0, false, 1);
      BigInteger bigInteger0 = maxWatchCard0.getDegree();
      assertEquals((byte) (-1), bigInteger0.byteValue());
  }

  @Test(timeout = 4000)
  public void test48()  throws Throwable  {
      Lits lits0 = new Lits();
      VecInt vecInt0 = new VecInt(2120, 0);
      lits0.getFromPool(0);
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(lits0, vecInt0, true, 4943);
      // Undeclared exception!
      try { 
        maxWatchCard0.register();
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.sat4j.minisat.constraints.card.MaxWatchCard", e);
      }
  }

  @Test(timeout = 4000)
  public void test49()  throws Throwable  {
      CardinalityDataStructure cardinalityDataStructure0 = new CardinalityDataStructure();
      ILits iLits0 = cardinalityDataStructure0.getVocabulary();
      IVecInt iVecInt0 = VecInt.EMPTY;
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(iLits0, iVecInt0, true, 0);
      maxWatchCard0.getCoef((-1177));
      assertEquals(0, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
  }

  @Test(timeout = 4000)
  public void test50()  throws Throwable  {
      MiniSATLearning<MixedDataStructureDanielWL> miniSATLearning0 = new MiniSATLearning<MixedDataStructureDanielWL>();
      MixedDataStructureDanielWL mixedDataStructureDanielWL0 = new MixedDataStructureDanielWL();
      VarOrderHeap varOrderHeap0 = new VarOrderHeap((IPhaseSelectionStrategy) null);
      LubyRestarts lubyRestarts0 = new LubyRestarts();
      SearchParams searchParams0 = new SearchParams(32, 0.0, (-1069.803757324563), (-1582));
      Solver<MixedDataStructureDanielWL> solver0 = new Solver<MixedDataStructureDanielWL>(miniSATLearning0, mixedDataStructureDanielWL0, searchParams0, varOrderHeap0, lubyRestarts0);
      IVecInt iVecInt0 = solver0.getOutLearnt();
      CardinalityDataStructure cardinalityDataStructure0 = new CardinalityDataStructure();
      ILits iLits0 = cardinalityDataStructure0.getVocabulary();
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(iLits0, iVecInt0, true, (-1580));
      maxWatchCard0.forwardActivity(1294.1276795605793);
      assertEquals((-1580), maxWatchCard0.requiredNumberOfSatisfiedLiterals());
  }

  @Test(timeout = 4000)
  public void test51()  throws Throwable  {
      Lits lits0 = new Lits();
      VecInt vecInt0 = new VecInt();
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(lits0, vecInt0, true, 1344);
      maxWatchCard0.getVocabulary();
      assertEquals(1344, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
  }

  @Test(timeout = 4000)
  public void test52()  throws Throwable  {
      VecInt vecInt0 = new VecInt();
      Lits lits0 = new Lits();
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(lits0, vecInt0, false, 0);
      WatcherBasedPrimeImplicantStrategy watcherBasedPrimeImplicantStrategy0 = new WatcherBasedPrimeImplicantStrategy((Comparator<Integer>) null);
      // Undeclared exception!
      try { 
        maxWatchCard0.propagatePI(watcherBasedPrimeImplicantStrategy0, 0);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // Not implemented yet!
         //
         verifyException("org.sat4j.minisat.constraints.card.MaxWatchCard", e);
      }
  }

  @Test(timeout = 4000)
  public void test53()  throws Throwable  {
      Lits lits0 = new Lits();
      VecInt vecInt0 = new VecInt(1309);
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(lits0, vecInt0, false, 1309);
      boolean boolean0 = maxWatchCard0.learnt();
      assertEquals((-1309), maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test54()  throws Throwable  {
      Lits lits0 = new Lits();
      VecInt vecInt0 = new VecInt(0, 2120);
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(lits0, vecInt0, true, 2120);
      maxWatchCard0.setActivity(1552.662129483772);
      assertEquals(2120, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
  }

  @Test(timeout = 4000)
  public void test55()  throws Throwable  {
      CardinalityDataStructure cardinalityDataStructure0 = new CardinalityDataStructure();
      ILits iLits0 = cardinalityDataStructure0.getVocabulary();
      VecInt vecInt0 = new VecInt();
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(iLits0, vecInt0, false, 496);
      // Undeclared exception!
      try { 
        maxWatchCard0.isSatisfied();
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // Not implemented yet!
         //
         verifyException("org.sat4j.minisat.constraints.card.MaxWatchCard", e);
      }
  }

  @Test(timeout = 4000)
  public void test56()  throws Throwable  {
      Lits lits0 = new Lits();
      VecInt vecInt0 = new VecInt(1394);
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(lits0, vecInt0, true, (-1));
      boolean boolean0 = maxWatchCard0.locked();
      assertEquals((-1), maxWatchCard0.requiredNumberOfSatisfiedLiterals());
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test57()  throws Throwable  {
      CardinalityDataStructure cardinalityDataStructure0 = new CardinalityDataStructure();
      ILits iLits0 = cardinalityDataStructure0.getVocabulary();
      VecInt vecInt0 = new VecInt();
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(iLits0, vecInt0, false, (-413));
      int int0 = maxWatchCard0.requiredNumberOfSatisfiedLiterals();
      assertEquals(413, int0);
  }

  @Test(timeout = 4000)
  public void test58()  throws Throwable  {
      CardinalityDataStructure cardinalityDataStructure0 = new CardinalityDataStructure();
      ILits iLits0 = cardinalityDataStructure0.getVocabulary();
      IVecInt iVecInt0 = VecInt.EMPTY;
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(iLits0, iVecInt0, true, (-339));
      // Undeclared exception!
      try { 
        maxWatchCard0.setLearnt();
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.sat4j.minisat.constraints.card.MaxWatchCard", e);
      }
  }

  @Test(timeout = 4000)
  public void test59()  throws Throwable  {
      CardinalityDataStructure cardinalityDataStructure0 = new CardinalityDataStructure();
      ILits iLits0 = cardinalityDataStructure0.getVocabulary();
      VecInt vecInt0 = new VecInt(1);
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(iLits0, vecInt0, true, 1);
      boolean boolean0 = maxWatchCard0.canBePropagatedMultipleTimes();
      assertFalse(boolean0);
      assertEquals(1, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
  }

  @Test(timeout = 4000)
  public void test60()  throws Throwable  {
      Lits lits0 = new Lits();
      VecInt vecInt0 = new VecInt(1);
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(lits0, vecInt0, true, 1);
      maxWatchCard0.size();
      assertEquals(1, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
  }

  @Test(timeout = 4000)
  public void test61()  throws Throwable  {
      CardinalityDataStructure cardinalityDataStructure0 = new CardinalityDataStructure();
      ILits iLits0 = cardinalityDataStructure0.getVocabulary();
      VecInt vecInt0 = new VecInt(1);
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(iLits0, vecInt0, false, 1);
      // Undeclared exception!
      try { 
        maxWatchCard0.get((-447));
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -447
         //
         verifyException("org.sat4j.minisat.constraints.card.MaxWatchCard", e);
      }
  }

  @Test(timeout = 4000)
  public void test62()  throws Throwable  {
      Lits lits0 = new Lits();
      VecInt vecInt0 = new VecInt();
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(lits0, vecInt0, false, 4843);
      // Undeclared exception!
      try { 
        maxWatchCard0.calcReasonOnTheFly(1391, vecInt0, vecInt0);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // Not implemented yet!
         //
         verifyException("org.sat4j.minisat.constraints.card.MaxWatchCard", e);
      }
  }

  @Test(timeout = 4000)
  public void test63()  throws Throwable  {
      CardinalityDataStructure cardinalityDataStructure0 = new CardinalityDataStructure();
      ILits iLits0 = cardinalityDataStructure0.getVocabulary();
      VecInt vecInt0 = new VecInt(1);
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(iLits0, vecInt0, false, 1);
      Constr constr0 = maxWatchCard0.toConstraint();
      assertEquals((-1), constr0.requiredNumberOfSatisfiedLiterals());
  }

  @Test(timeout = 4000)
  public void test64()  throws Throwable  {
      CardinalityDataStructure cardinalityDataStructure0 = new CardinalityDataStructure();
      ILits iLits0 = cardinalityDataStructure0.getVocabulary();
      VecInt vecInt0 = new VecInt(1);
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(iLits0, vecInt0, false, 1);
      maxWatchCard0.undo(1);
      assertEquals((-1), maxWatchCard0.requiredNumberOfSatisfiedLiterals());
  }

  @Test(timeout = 4000)
  public void test65()  throws Throwable  {
      Lits lits0 = new Lits();
      VecInt vecInt0 = new VecInt(0, 0);
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(lits0, vecInt0, true, 0);
      maxWatchCard0.incActivity(0);
      assertEquals(0, maxWatchCard0.requiredNumberOfSatisfiedLiterals());
  }

  @Test(timeout = 4000)
  public void test66()  throws Throwable  {
      Lits lits0 = new Lits();
      VecInt vecInt0 = new VecInt();
      MaxWatchCard maxWatchCard0 = new MaxWatchCard(lits0, vecInt0, true, 1);
      // Undeclared exception!
      try { 
        maxWatchCard0.assertConstraintIfNeeded((UnitPropagationListener) null);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.sat4j.minisat.constraints.card.MaxWatchCard", e);
      }
  }
}
